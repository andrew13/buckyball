<?php define('BNULL', 'THIS IS A DUMMY VALUE TO DISTINCT BETWEEN LACK OF ARGUMENT/VALUE AND PHP NULL VALUE'); class BClass { public static function i($new=false, array $args=array()) { if (is_object($new)) { $class = get_class($new); $new = false; } else { $class = get_called_class(); } return BClassRegistry::i()->instance($class, $args, !$new); } } class BApp extends BClass { protected static $_compat = array(); protected $_vars = array(); public static function compat($feature) { if (!empty(static::$_compat[$feature])) { return static::$_compat[$feature]; } switch ($feature) { case 'PHP5.3': $compat = version_compare(phpversion(), '5.3.0', '>='); break; default: throw new BException(BApp::t('Unknown feature: %s', $feature)); } static::$_compat[$feature] = $compat; return $compat; } public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { BDebug::i(); } public function config($config) { if (is_array($config)) { BConfig::i()->add($config); } elseif (is_string($config) && is_file($config)) { BConfig::i()->addFile($config); } else { throw new BException("Invalid configuration argument"); } return $this; } public function load($folders='.') { if (is_string($folders)) { $folders = explode(',', $folders); } $modules = BModuleRegistry::i(); foreach ($folders as $folder) { $modules->scan($folder); } return $this; } public function run() { BSession::i()->open(); BModuleRegistry::i()->bootstrap(); BDb::i()->runMigrationScripts(); BFrontController::i()->dispatch(); BSession::i()->close(); return $this; } public static function log($message, $args=array(), $data=array()) { $data['message'] = static::t($message, $args); BDebug::i()->log($data); } public static function t($string, $args=array()) { return Blocale::i()->t($string, $args); } public static function m($modName=null) { $reg = BModuleRegistry::i(); return is_null($modName) ? $reg->currentModule() : $reg->module($modName); } public static function baseUrl($full=true) { static $baseUrl = array(); if (empty($baseUrl[(int)$full])) { $r = BRequest::i(); $baseUrl[(int)$full] = $full ? $r->baseUrl() : $r->webRoot(); } return $baseUrl[(int)$full]; } public function set($key, $val) { $this->_vars[$key] = $val; return $this; } public function get($key) { return isset($this->_vars[$key]) ? $this->_vars[$key] : null; } } class BException extends Exception { public function __construct($message="", $code=0) { parent::__construct($message, $code); BApp::log($message, array(), array('event'=>'exception', 'code'=>$code, 'file'=>$this->getFile(), 'line'=>$this->getLine())); } } class BConfig extends BClass { protected $_config = array(); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function add(array $config) { $this->_config = BUtil::arrayMerge($this->_config, $config); return $this; } public function addFile($filename) { if (!is_readable($filename)) { throw new BException(BApp::t('Invalid configuration file name: %s', $filename)); } $config = BUtil::fromJson(file_get_contents($filename)); if (!$config) { throw new BException(BApp::t('Invalid configuration contents: %s', $filename)); } $this->add($config); return $this; } public function get($path) { $root = $this->_config; foreach (explode('/', $path) as $key) { if (!isset($root[$key])) { return null; } $root = $root[$key]; } return $root; } } class BClassRegistry extends BClass { static protected $_instance; protected $_classes = array(); protected $_methods = array(); protected $_properties = array(); protected $_singletons = array(); public static function i($new=false, array $args=array(), $forceRefresh=false) { if (!static::$_instance) { static::$_instance = new BClassRegistry; } if (!$new && !$forceRefresh) { return static::$_instance; } $class = get_called_class(); return static::$_instance->instance($class, $args, !$new); } public function overrideClass($class, $newClass, $replaceSingleton=false) { $this->_classes[$class] = array( 'class_name' => $newClass, 'module_name' => BModuleRegistry::currentModuleName(), ); if ($replaceSingleton && !empty($this->_singletons[$class]) && get_class($this->_singletons[$class])!==$newClass) { $this->_singletons[$class] = $this->instance($newClass); } return $this; } public function overrideMethod($class, $method, $callback, $static=false) { $this->_methods[$class][$static ? 1 : 0][$method]['override'] = array( 'module_name' => BModuleRegistry::currentModuleName(), 'callback' => $callback, ); return $this; } public function augmentMethod($class, $method, $callback, $static=false) { $this->_methods[$class][$static ? 1 : 0][$method]['augment'][] = array( 'module_name' => BModuleRegistry::currentModuleName(), 'callback' => $callback, ); return $this; } public function augmentProperty($class, $property, $op, $type, $callback) { if ($op!=='set' && $op!=='get') { throw new BException(BApp::t('Invalid property augmentation operator: %s', $op)); } if ($type!=='override' && $type!=='before' && $type!=='after') { throw new BException(BApp::t('Invalid property augmentation type: %s', $type)); } $entry = array( 'module_name' => BModuleRegistry::currentModuleName(), 'callback' => $callback, ); if ($type==='override') { $this->_properties[$class][$property][$op.'_'.$type] = $entry; } else { $this->_properties[$class][$property][$op.'_'.$type][] = $entry; } return $this; } public function callMethod($origObject, $method, array $args=array()) { $class = get_class($origObject); if (!empty($this->_methods[$class][0][$method]['override'])) { $overridden = true; $callback = $this->_methods[$class][0][$method]['override']['callback']; array_unshift($args, $origObject); } else { $overridden = false; $callback = array($origObject, $method); } $result = call_user_func_array($callback, $args); if (!empty($this->_methods[$class][0][$method]['augment'])) { if (!$overridden) { array_unshift($args, $origObject); } array_unshift($args, $result); foreach ($this->_methods[$class][0][$method]['augment'] as $augment) { $result = call_user_func_array($augment['callback'], $args); $args[0] = $result; } } return $result; } public function callStaticMethod($class, $method, array $args=array()) { $callback = !empty($this->_methods[$class][1][$method]) ? $this->_methods[$class][1][$method]['override']['callback'] : array($class, $method); $result = call_user_func_array($callback, $args); if (!empty($this->_methods[$class][1][$method]['augment'])) { array_unshift($args, $result); foreach ($this->_methods[$class][1][$method]['augment'] as $augment) { $result = call_user_func_array($augment['callback'], $args); $args[0] = $result; } } return $result; } public function callSetter($origObject, $property, $value) { $class = get_class($origObject); if (!empty($this->_properties[$class][$method]['set_before'])) { foreach ($this->_properties[$class][$method]['set_before'] as $entry) { call_user_func($entry['callback'], $origObject, $property, $value); } } if (!empty($this->_properties[$class][$method]['set_override'])) { $callback = $this->_properties[$class][$method]['set_override']['callback']; call_user_func($callback, $origObject, $property, $value); } else { $origObject->$property = $value; } if (!empty($this->_properties[$class][$method]['set_after'])) { foreach ($this->_properties[$class][$method]['set_after'] as $entry) { call_user_func($entry['callback'], $origObject, $property, $value); } } } public function callGetter($origObject, $property) { $class = get_class($origObject); if (!empty($this->_properties[$class][$method]['get_override'])) { $callback = $this->_properties[$class][$method]['get_override']['callback']; $result = call_user_func($callback, $origObject, $property); } else { $result = $origObject->$property; } if (!empty($this->_properties[$class][$method]['get_after'])) { foreach ($this->_properties[$class][$method]['get_after'] as $entry) { $result = call_user_func($entry['callback'], $origObject, $property, $result); } } return $result; } public function className($class) { return !empty($this->_classes[$class]) ? $this->_classes[$class]['class_name'] : $class; } public function instance($class, array $args=array(), $singleton=false) { if ($singleton && !empty($this->_singletons[$class])) { return $this->_singletons[$class]; } $className = $this->className($class); if (!class_exists($className, true)) { throw new BException(BApp::t('Invalid class name: %s', $className)); } $instance = new $className($args); if (!empty($this->_methods[$class])) { $instance = $this->instance('BClassDecorator', array($instance)); } if ($singleton) { $this->_singletons[$class] = $instance; } return $instance; } } class BClassDecorator { protected $_decoratedComponent; public function __construct($args) { $class = array_shift($args); $this->_decoratedComponent = is_string($class) ? BClassRegistry::i()->instance($class, $args) : $class; } public function __call($name, array $args) { return BClassRegistry::i()->callMethod($this->_decoratedComponent, $name, $args); } public static function __callStatic($name, array $args) { return BClassRegistry::i()->callStaticMethod(get_called_class(), $name, $args); } public function __set($name, $value) { BClassRegistry::i()->callSetter($this->_decoratedComponent, $name, $value); } public function __get($name) { return BClassRegistry::i()->callGetter($this->_decoratedComponent, $name); } public function __unset($name) { unset($this->_decoratedComponent->$name); } public function __isset($name) { return isset($this->_decoratedComponent->$name); } public function __toString() { return (string)$this->_decoratedComponent; } public function __sleep() { if (method_exists($this->_decoratedComponent, '__sleep')) { return $this->_decoratedComponent->__sleep(); } return array(); } public function __wakeup() { if (method_exists($this->_decoratedComponent, '__wakeup')) { $this->_decoratedComponent->__wakeup(); } } public function __invoke() { if (is_callable($this->_decoratedComponent)) { return $this->_decoratedComponent(func_get_args()); } return null; } } class BEventRegistry extends BClass { protected $_events = array(); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function event($eventName, $args=array()) { if (is_array($eventName)) { foreach ($eventName as $event) { $this->event($event[0], !empty($event[1]) ? $event[1] : array()); } return $this; } $this->_events[$eventName] = array( 'observers' => array(), 'args' => $args, ); return $this; } public function observe($eventName, $callback=null, $args=array()) { if (is_array($eventName)) { foreach ($eventName as $obs) { $this->observe($obs[0], $obs[1], !empty($obs[2]) ? $obs[2] : array()); } return $this; } $observer = array('callback'=>$callback, 'args'=>$args); if (($moduleName = BModuleRegistry::currentModuleName())) { $observer['module_name'] = $moduleName; } $this->_events[$eventName]['observers'][] = $observer; return $this; } public function watch($eventName, $callback=null, $args=array()) { return $this->observe($eventName, $callback, $args); } public function on($eventName, $callback=null, $args=array()) { return $this->observe($eventName, $callback, $args); } public function dispatch($eventName, $args=array()) { $result = array(); if (!empty($this->_events[$eventName])) { foreach ($this->_events[$eventName]['observers'] as $observer) { if (!empty($this->_events[$eventName]['args'])) { $args = array_merge($this->_events[$eventName]['args'], $args); } if (!empty($observer['args'])) { $args = array_merge($observer['args'], $args); } if (is_string($observer['callback'])) { $r = explode('.', $observer['callback']); if (sizeof($r)==2) { $observer['callback'] = array($r[0]::i(), $r[1]); } } if (is_array($observer['callback']) && is_string($observer['callback'][0])) { $observer['callback'][0] = BClassRegistry::i()->instance($observer['callback'][0], array(), true); } BModuleRegistry::i()->currentModule(!empty($observer['module_name']) ? $observer['module_name'] : null); $result[] = call_user_func($observer['callback'], $args); } BModuleRegistry::i()->currentModule(null); } return $result; } public function fire($eventName, $args=array()) { return $this->dispatch($eventName, $args); } } class BSession extends BClass { public $data = null; protected $_sessionId; protected $_phpSessionOpen = false; protected $_dirty = false; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function open($id=null, $autoClose=true) { if (!is_null($this->data)) { return $this; } $config = BConfig::i()->get('cookie'); session_set_cookie_params($config['timeout'], $config['path'], $config['domain']); session_name($config['name']); if (!empty($id) || ($id = BRequest::i()->get('SID'))) { session_id($id); } @session_start(); $this->_phpSessionOpen = true; $this->_sessionId = session_id(); $namespace = $config['session_namespace']; $this->data = !empty($_SESSION[$namespace]) ? $_SESSION[$namespace] : array(); if (!empty($this->data['_locale'])) { if (is_array($this->data['_locale'])) { foreach ($this->data['_locale'] as $c=>$l) { setlocale($c, $l); } } elseif (is_string($this->data['_locale'])) { setlocale(LC_ALL, $this->data['_locale']); } } if (!empty($this->data['_timezone'])) { date_default_timezone_set($this->data['_timezone']); } if ($autoClose) { session_write_close(); $this->_phpSessionOpen = false; } return $this; } public function dirty($flag=BNULL) { if (BNULL===$flag) { return $this->_dirty; } $this->_dirty = $flag; return $this; } public function data($key=BNULL, $value=BNULL) { if (BNULL===$key) { return $this->data; } if (BNULL===$value) { return isset($this->data[$key]) ? $this->data[$key] : null; } if (!isset($this->data[$key]) || $this->data[$key]!==$value) { $this->dirty(true); } $this->data[$key] = $value; return $this; } public function pop($key) { $data = $this->data($key); $this->data($key, null); return $data; } public function &dataToUpdate() { $this->dirty(true); return $this->data; } public function close() { if (!$this->dirty()) { return; } if (!$this->_phpSessionOpen) { session_start(); } $namespace = BConfig::i()->get('cookie/session_namespace'); $_SESSION[$namespace] = $this->data; session_write_close(); $this->_phpSessionOpen = false; $this->dirty(false); return $this; } public function sessionId() { return $this->_sessionId; } public function addMessage($msg, $type='info', $tag='_') { $this->dirty(true); $this->data['_messages'][$tag][] = array('msg'=>$msg, 'type'=>$type); return $this; } public function messages($tags='_') { if (empty($this->data['_messages'])) { return array(); } $tags = explode(',', $tags); $msgs = array(); foreach ($tags as $tag) { if (empty($this->data['_messages'][$tag])) continue; foreach ($avail[$tag] as $i=>$m) { $msgs[] = $m; unset($this->data['_messages'][$tag][$i]); $this->dirty(true); } } return $msgs; } } class BUtil { protected static $_hashAlgo = 'sha256'; protected static $_hashIter = 3; protected static $_hashSep = '$'; public static function toJson($data) { return json_encode($data); } public static function fromJson($json, $asObject=false) { $obj = json_decode($json); return $asObject ? $obj : static::objectToArray($obj); } public static function objectToArray($d) { if (is_object($d)) { $d = get_object_vars($d); } if (is_array($d)) { return array_map('BUtil::objectToArray', $d); } return $d; } public static function arrayToObject($d) { if (is_array($d)) { return (object) array_map('BUtil::objectToArray', $d); } return $d; } public static function sprintfn($format, $args = array()) { $args = (array)$args; $arg_nums = array_slice(array_flip(array_keys(array(0 => 0) + $args)), 1); for ($pos = 0; preg_match('/(?<=%)([a-zA-Z_]\w*)(?=\$)/', $format, $match, PREG_OFFSET_CAPTURE, $pos);) { $arg_pos = $match[0][1]; $arg_len = strlen($match[0][0]); $arg_key = $match[1][0]; if (! array_key_exists($arg_key, $arg_nums)) { user_error("sprintfn(): Missing argument '${arg_key}'", E_USER_WARNING); return false; } $format = substr_replace($format, $replace = $arg_nums[$arg_key], $arg_pos, $arg_len); $pos = $arg_pos + strlen($replace); } return vsprintf($format, array_values($args)); } public static function injectVars($str, $vars) { $from = array(); $to = array(); foreach ($vars as $k=>$v) { $from[] = ':'.$k; $to[] = $v; } return str_replace($from, $to, $str); } public static function arrayMerge() { $arrays = func_get_args(); $base = array_shift($arrays); if(!is_array($base)) $base = empty($base) ? array() : array($base); foreach($arrays as $append) { if(!is_array($append)) $append = array($append); foreach($append as $key => $value) { if(!array_key_exists($key, $base) and !is_numeric($key)) { $base[$key] = $append[$key]; continue; } if(is_array($value) or is_array($base[$key])) { $base[$key] = static::arrayMerge($base[$key], $append[$key]); } else if(is_numeric($key)) { if(!in_array($value, $base)) $base[] = $value; } else { $base[$key] = $value; } } } return $base; } public static function arrayCompare(array $array1, array $array2) { $diff = false; foreach ($array1 as $key => $value) { if (!array_key_exists($key,$array2)) { $diff[0][$key] = $value; } elseif (is_array($value)) { if (!is_array($array2[$key])) { $diff[0][$key] = $value; $diff[1][$key] = $array2[$key]; } else { $new = static::arrayCompare($value, $array2[$key]); if ($new !== false) { if (isset($new[0])) $diff[0][$key] = $new[0]; if (isset($new[1])) $diff[1][$key] = $new[1]; } } } elseif ($array2[$key] !== $value) { $diff[0][$key] = $value; $diff[1][$key] = $array2[$key]; } } foreach ($array2 as $key => $value) { if (!array_key_exists($key,$array1)) { $diff[1][$key] = $value; } } return $diff; } public static function hashAlgo($algo=null) { if (is_null($algo)) { return static::$_hashAlgo; } static::$_hashAlgo = $algo; } public static function hashIter($iter=null) { if (is_null($iter)) { return static::$_hashIter; } static::$iter = $iter; } public static function randomString($strLen=8, $chars='abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ23456789') { $charsLen = strlen($chars)-1; $str = ''; for ($i=0; $i<$strLen; $i++) { $str .= $chars[mt_rand(0, $charsLen)]; } return $str; } public static function randomPattern($pattern) { static $chars = array('L'=>'bcdfghjkmnpqrstvwxyz', 'U'=>'BCDFGHJKLMNPQRSTVWXYZ', 'D'=>'123456789'); while (preg_match('#\{([ULD]+)([0-9]+)\}#i', $pattern, $m)) { for ($i=0, $c=''; $i<strlen($m[1]); $i++) $c .= $chars[$m[1][$i]]; $pattern = preg_replace('#'.preg_quote($m[0]).'#', BUtil::randomString($m[2], $c), $pattern, 1); } return $pattern; } public static function saltedHash($string, $salt, $algo=null) { $algo = !is_null($algo) ? $algo : static::$_hashAlgo; return hash($algo, $salt.$string); } public static function fullSaltedHash($string, $salt=null, $algo=null, $iter=null) { $algo = !is_null($algo) ? $algo : static::$_hashAlgo; $iter = !is_null($iter) ? $iter : static::$_hashIter; $s = static::$_hashSep; $hash = $s.$algo.$s.$iter; for ($i=0; $i<$iter; $i++) { $salt1 = !is_null($salt) ? $salt : static::randomString(); $hash .= $s.$salt1; $string = static::saltedHash($string, $salt1, $algo); } return $hash.$s.$string; } public static function validateSaltedHash($string, $storedHash) { $sep = $storedHash[0]; $arr = explode($sep, $storedHash); array_shift($arr); $algo = array_shift($arr); $iter = array_shift($arr); $verifyHash = $string; for ($i=0; $i<$iter; $i++) { $salt = array_shift($arr); $verifyHash = static::saltedHash($verifyHash, $salt, $algo); } $knownHash = array_shift($arr); return $verifyHash===$knownHash; } public static function maskFields($source, $fields, $inverse=false) { if (is_string($fields)) { $fields = explode(',', $fields); } $result = array(); if (!$inverse) { foreach ($fields as $k) $result[$k] = isset($source[$k]) ? $source[$k] : null; } else { foreach ($source as $k=>$v) if (!in_array($k, $fields)) $result[$k] = $v; } return $result; } public static function post($url, $data) { $request = http_build_query($data); $opts = array( 'http' => array( 'method' => 'POST', 'header' => "Content-Type: application/x-www-form-urlencoded\r\n" ."Content-Length: ".strlen($request)."\r\n", 'content' => $request, 'timeout' => 5, ), ); $context = stream_context_create($opts); $response = file_get_contents($url, false, $context); parse_str($response, $result); return $result; } public static function normalizePath($path) { $path = str_replace('\\', '/', $path); if (strpos($path, '/..')!==false) { $a = explode('/', $path); $b = array(); foreach ($a as $p) { if ($p==='..') array_pop($b); else $b[] = $p; } $path = join('/', $b); } return $path; } }  class ORM { const WHERE_FRAGMENT = 0; const WHERE_VALUES = 1; protected static $_config = array( 'connection_string' => 'sqlite::memory:', 'id_column' => 'id', 'id_column_overrides' => array(), 'error_mode' => PDO::ERRMODE_EXCEPTION, 'username' => null, 'password' => null, 'driver_options' => null, 'identifier_quote_character' => null, 'logging' => false, 'caching' => false, ); protected static $_db; protected static $_last_query; protected static $_query_log = array(); protected static $_query_cache = array(); protected $_table_name; protected $_table_alias = null; protected $_values = array(); protected $_result_columns = array('*'); protected $_using_default_result_columns = true; protected $_join_sources = array(); protected $_distinct = false; protected $_is_raw_query = false; protected $_raw_query = ''; protected $_raw_parameters = array(); protected $_where_conditions = array(); protected $_limit = null; protected $_offset = null; protected $_order_by = array(); protected $_group_by = array(); protected $_data = array(); protected $_dirty_fields = array(); protected $_is_new = false; protected $_instance_id_column = null; public static function configure($key, $value=null) { if (is_null($value)) { $value = $key; $key = 'connection_string'; } static::$_config[$key] = $value; } public static function for_table($table_name) { static::_setup_db(); return new static($table_name); } protected static function _setup_db() { if (!is_object(static::$_db)) { $connection_string = static::$_config['connection_string']; $username = static::$_config['username']; $password = static::$_config['password']; $driver_options = static::$_config['driver_options']; $db = new PDO($connection_string, $username, $password, $driver_options); $db->setAttribute(PDO::ATTR_ERRMODE, static::$_config['error_mode']); static::set_db($db); } } public static function set_db($db) { static::$_db = $db; static::_setup_identifier_quote_character(); } public static function _setup_identifier_quote_character() { if (is_null(static::$_config['identifier_quote_character'])) { static::$_config['identifier_quote_character'] = static::_detect_identifier_quote_character(); } } protected static function _detect_identifier_quote_character() { switch(static::$_db->getAttribute(PDO::ATTR_DRIVER_NAME)) { case 'pgsql': case 'sqlsrv': case 'dblib': case 'mssql': case 'sybase': return '"'; case 'mysql': case 'sqlite': case 'sqlite2': default: return '`'; } } public static function get_db() { static::_setup_db(); return static::$_db; } protected static function _log_query($query, $parameters) { if (!static::$_config['logging']) { return false; } if (count($parameters) > 0) { $parameters = array_map(array(static::$_db, 'quote'), $parameters); $query = str_replace("?", "%s", $query); $bound_query = vsprintf($query, $parameters); } else { $bound_query = $query; } static::$_last_query = $bound_query; static::$_query_log[] = $bound_query; return true; } public static function get_last_query() { return static::$_last_query; } public static function get_query_log() { return static::$_query_log; } protected function __construct($table_name, $data=array()) { $this->_table_name = $table_name; $this->_data = $data; } public function create($data=null) { $this->_is_new = true; if (!is_null($data)) { return $this->hydrate($data)->force_all_dirty(); } return $this; } public function use_id_column($id_column) { $this->_instance_id_column = $id_column; return $this; } protected function _create_instance_from_row($row) { $instance = static::for_table($this->_table_name); $instance->use_id_column($this->_instance_id_column); $instance->hydrate($row); return $instance; } public function find_one($id=null) { if (!is_null($id)) { $this->where_id_is($id); } $this->limit(1); $rows = $this->_run(); if (empty($rows)) { return false; } return $this->_create_instance_from_row($rows[0]); } public function find_many() { $rows = $this->_run(); return array_map(array($this, '_create_instance_from_row'), $rows); } public function count() { $this->select_expr('COUNT(*)', 'count'); $result = $this->find_one(); return ($result !== false && isset($result->count)) ? (int) $result->count : 0; } public function hydrate($data=array()) { $this->_data = $data; return $this; } public function force_all_dirty() { $this->_dirty_fields = $this->_data; return $this; } public function raw_query($query, $parameters) { $this->_is_raw_query = true; $this->_raw_query = $query; $this->_raw_parameters = $parameters; return $this; } public function table_alias($alias) { $this->_table_alias = $alias; return $this; } protected function _add_result_column($expr, $alias=null) { if (!is_null($alias)) { $expr .= " AS " . $this->_quote_identifier($alias); } if ($this->_using_default_result_columns) { $this->_result_columns = array($expr); $this->_using_default_result_columns = false; } else { $this->_result_columns[] = $expr; } return $this; } public function select($column, $alias=null) { $column = $this->_quote_identifier($column); return $this->_add_result_column($column, $alias); } public function select_expr($expr, $alias=null) { return $this->_add_result_column($expr, $alias); } public function distinct() { $this->_distinct = true; return $this; } protected function _add_join_source($join_operator, $table, $constraint, $table_alias=null) { $join_operator = trim("{$join_operator} JOIN"); $table = $this->_quote_identifier($table); if (!is_null($table_alias)) { $table_alias = $this->_quote_identifier($table_alias); $table .= " {$table_alias}"; } if (is_array($constraint)) { list($first_column, $operator, $second_column) = $constraint; $first_column = $this->_quote_identifier($first_column); $second_column = $this->_quote_identifier($second_column); $constraint = "{$first_column} {$operator} {$second_column}"; } $this->_join_sources[] = "{$join_operator} {$table} ON {$constraint}"; return $this; } public function join($table, $constraint, $table_alias=null) { return $this->_add_join_source("", $table, $constraint, $table_alias); } public function inner_join($table, $constraint, $table_alias=null) { return $this->_add_join_source("INNER", $table, $constraint, $table_alias); } public function left_outer_join($table, $constraint, $table_alias=null) { return $this->_add_join_source("LEFT OUTER", $table, $constraint, $table_alias); } public function right_outer_join($table, $constraint, $table_alias=null) { return $this->_add_join_source("RIGHT OUTER", $table, $constraint, $table_alias); } public function full_outer_join($table, $constraint, $table_alias=null) { return $this->_add_join_source("FULL OUTER", $table, $constraint, $table_alias); } protected function _add_where($fragment, $values=array()) { if (!is_array($values)) { $values = array($values); } $this->_where_conditions[] = array( static::WHERE_FRAGMENT => $fragment, static::WHERE_VALUES => $values, ); return $this; } protected function _add_simple_where($column_name, $separator, $value) { $column_name = $this->_quote_identifier($column_name); return $this->_add_where("{$column_name} {$separator} ?", $value); } protected function _create_placeholders($number_of_placeholders) { return join(", ", array_fill(0, $number_of_placeholders, "?")); } public function where($column_name, $value) { return $this->where_equal($column_name, $value); } public function where_equal($column_name, $value) { return $this->_add_simple_where($column_name, '=', $value); } public function where_not_equal($column_name, $value) { return $this->_add_simple_where($column_name, '!=', $value); } public function where_id_is($id) { return $this->where($this->_get_id_column_name(), $id); } public function where_like($column_name, $value) { return $this->_add_simple_where($column_name, 'LIKE', $value); } public function where_not_like($column_name, $value) { return $this->_add_simple_where($column_name, 'NOT LIKE', $value); } public function where_gt($column_name, $value) { return $this->_add_simple_where($column_name, '>', $value); } public function where_lt($column_name, $value) { return $this->_add_simple_where($column_name, '<', $value); } public function where_gte($column_name, $value) { return $this->_add_simple_where($column_name, '>=', $value); } public function where_lte($column_name, $value) { return $this->_add_simple_where($column_name, '<=', $value); } public function where_in($column_name, $values) { $column_name = $this->_quote_identifier($column_name); $placeholders = $this->_create_placeholders(count($values)); return $this->_add_where("{$column_name} IN ({$placeholders})", $values); } public function where_not_in($column_name, $values) { $column_name = $this->_quote_identifier($column_name); $placeholders = $this->_create_placeholders(count($values)); return $this->_add_where("{$column_name} NOT IN ({$placeholders})", $values); } public function where_null($column_name) { $column_name = $this->_quote_identifier($column_name); return $this->_add_where("{$column_name} IS NULL"); } public function where_not_null($column_name) { $column_name = $this->_quote_identifier($column_name); return $this->_add_where("{$column_name} IS NOT NULL"); } public function where_raw($clause, $parameters=array()) { return $this->_add_where($clause, $parameters); } public function limit($limit) { $this->_limit = $limit; return $this; } public function offset($offset) { $this->_offset = $offset; return $this; } protected function _add_order_by($column_name, $ordering) { $column_name = $this->_quote_identifier($column_name); $this->_order_by[] = "{$column_name} {$ordering}"; return $this; } public function order_by_desc($column_name) { return $this->_add_order_by($column_name, 'DESC'); } public function order_by_asc($column_name) { return $this->_add_order_by($column_name, 'ASC'); } public function group_by($column_name) { $column_name = $this->_quote_identifier($column_name); $this->_group_by[] = $column_name; return $this; } protected function _build_select() { if ($this->_is_raw_query) { $this->_values = $this->_raw_parameters; return $this->_raw_query; } return $this->_join_if_not_empty(" ", array( $this->_build_select_start(), $this->_build_join(), $this->_build_where(), $this->_build_group_by(), $this->_build_order_by(), $this->_build_limit(), $this->_build_offset(), )); } protected function _build_select_start() { $result_columns = join(', ', $this->_result_columns); if ($this->_distinct) { $result_columns = 'DISTINCT ' . $result_columns; } $fragment = "SELECT {$result_columns} FROM " . $this->_quote_identifier($this->_table_name); if (!is_null($this->_table_alias)) { $fragment .= " " . $this->_quote_identifier($this->_table_alias); } return $fragment; } protected function _build_join() { if (count($this->_join_sources) === 0) { return ''; } return join(" ", $this->_join_sources); } protected function _build_where() { if (count($this->_where_conditions) === 0) { return ''; } $where_conditions = array(); foreach ($this->_where_conditions as $condition) { $where_conditions[] = $condition[static::WHERE_FRAGMENT]; $this->_values = array_merge($this->_values, $condition[static::WHERE_VALUES]); } return "WHERE " . join(" AND ", $where_conditions); } protected function _build_group_by() { if (count($this->_group_by) === 0) { return ''; } return "GROUP BY " . join(", ", $this->_group_by); } protected function _build_order_by() { if (count($this->_order_by) === 0) { return ''; } return "ORDER BY " . join(", ", $this->_order_by); } protected function _build_limit() { if (!is_null($this->_limit)) { return "LIMIT " . $this->_limit; } return ''; } protected function _build_offset() { if (!is_null($this->_offset)) { return "OFFSET " . $this->_offset; } return ''; } protected function _join_if_not_empty($glue, $pieces) { $filtered_pieces = array(); foreach ($pieces as $piece) { if (is_string($piece)) { $piece = trim($piece); } if (!empty($piece)) { $filtered_pieces[] = $piece; } } return join($glue, $filtered_pieces); } protected function _quote_identifier($identifier) { $parts = explode('.', $identifier); $parts = array_map(array($this, '_quote_identifier_part'), $parts); return join('.', $parts); } protected function _quote_identifier_part($part) { if ($part === '*') { return $part; } $quote_character = static::$_config['identifier_quote_character']; return $quote_character . $part . $quote_character; } protected static function _create_cache_key($query, $parameters) { $parameter_string = join(',', $parameters); $key = $query . ':' . $parameter_string; return sha1($key); } protected static function _check_query_cache($cache_key) { if (isset(static::$_query_cache[$cache_key])) { return static::$_query_cache[$cache_key]; } return false; } public static function clear_cache() { static::$_query_cache = array(); } protected static function _cache_query_result($cache_key, $value) { static::$_query_cache[$cache_key] = $value; } protected function _run() { $query = $this->_build_select(); $caching_enabled = static::$_config['caching']; if ($caching_enabled) { $cache_key = static::_create_cache_key($query, $this->_values); $cached_result = static::_check_query_cache($cache_key); if ($cached_result !== false) { return $cached_result; } } static::_log_query($query, $this->_values); $statement = static::$_db->prepare($query); try { $statement->execute($this->_values); } catch (Exception $e) { echo $query; print_r($e); exit; } $rows = array(); while ($row = $statement->fetch(PDO::FETCH_ASSOC)) { $rows[] = $row; } if ($caching_enabled) { static::_cache_query_result($cache_key, $rows); } return $rows; } public function as_array() { if (func_num_args() === 0) { return $this->_data; } $args = func_get_args(); return array_intersect_key($this->_data, array_flip($args)); } public function get($key) { return isset($this->_data[$key]) ? $this->_data[$key] : null; } protected function _get_id_column_name() { if (!is_null($this->_instance_id_column)) { return $this->_instance_id_column; } if (isset(static::$_config['id_column_overrides'][$this->_table_name])) { return static::$_config['id_column_overrides'][$this->_table_name]; } else { return static::$_config['id_column']; } } public function id() { return $this->get($this->_get_id_column_name()); } public function set($key, $value) { $this->_data[$key] = $value; $this->_dirty_fields[$key] = $value; } public function is_dirty($key) { return isset($this->_dirty_fields[$key]); } public function save() { $query = array(); $values = array_values($this->_dirty_fields); if (!$this->_is_new) { if (count($values) == 0) { return true; } $query = $this->_build_update(); $values[] = $this->id(); } else { $query = $this->_build_insert(); } static::_log_query($query, $values); $statement = static::$_db->prepare($query); $success = $statement->execute($values); if ($this->_is_new) { $this->_is_new = false; if (is_null($this->id())) { $this->_data[$this->_get_id_column_name()] = static::$_db->lastInsertId(); } } $this->_dirty_fields = array(); return $success; } protected function _build_update() { $query = array(); $query[] = "UPDATE {$this->_quote_identifier($this->_table_name)} SET"; $field_list = array(); foreach ($this->_dirty_fields as $key => $value) { $field_list[] = "{$this->_quote_identifier($key)} = ?"; } $query[] = join(", ", $field_list); $query[] = "WHERE"; $query[] = $this->_quote_identifier($this->_get_id_column_name()); $query[] = "= ?"; return join(" ", $query); } protected function _build_insert() { $query[] = "INSERT INTO"; $query[] = $this->_quote_identifier($this->_table_name); $field_list = array_map(array($this, '_quote_identifier'), array_keys($this->_dirty_fields)); $query[] = "(" . join(", ", $field_list) . ")"; $query[] = "VALUES"; $placeholders = $this->_create_placeholders(count($this->_dirty_fields)); $query[] = "({$placeholders})"; return join(" ", $query); } public function delete() { $query = join(" ", array( "DELETE FROM", $this->_quote_identifier($this->_table_name), "WHERE", $this->_quote_identifier($this->_get_id_column_name()), "= ?", )); $params = array($this->id()); static::_log_query($query, $params); $statement = static::$_db->prepare($query); return $statement->execute($params); } public function __get($key) { return $this->get($key); } public function __set($key, $value) { $this->set($key, $value); } public function __isset($key) { return isset($this->_data[$key]); } }  class ORMWrapper extends ORM { protected $_class_name; public function set_class_name($class_name) { $this->_class_name = $class_name; } public function filter() { $args = func_get_args(); $filter_function = array_shift($args); array_unshift($args, $this); if (method_exists($this->_class_name, $filter_function)) { return call_user_func_array(array($this->_class_name, $filter_function), $args); } } public static function for_table($table_name) { static::_setup_db(); return new static($table_name); } protected function _create_model_instance($orm) { if ($orm === false) { return false; } $model = new $this->_class_name(); $model->set_orm($orm); return $model; } public function find_one($id=null) { return $this->_create_model_instance(parent::find_one($id)); } public function find_many() { return array_map(array($this, '_create_model_instance'), parent::find_many()); } public function create($data=null) { return $this->_create_model_instance(parent::create($data)); } } class Model { const DEFAULT_ID_COLUMN = 'id'; const DEFAULT_FOREIGN_KEY_SUFFIX = '_id'; public $orm; protected static function _get_static_property($class_name, $property, $default=null) { if (!class_exists($class_name) || !property_exists($class_name, $property)) { return $default; } $properties = get_class_vars($class_name); return $properties[$property]; } protected static function _get_table_name($class_name) { $specified_table_name = static::_get_static_property($class_name, '_table'); if (is_null($specified_table_name)) { return static::_class_name_to_table_name($class_name); } return $specified_table_name; } protected static function _class_name_to_table_name($class_name) { return strtolower(preg_replace('/(?<=[a-z])([A-Z])/', '_$1', $class_name)); } protected static function _get_id_column_name($class_name) { return static::_get_static_property($class_name, '_id_column', static::DEFAULT_ID_COLUMN); } protected static function _build_foreign_key_name($specified_foreign_key_name, $table_name) { if (!is_null($specified_foreign_key_name)) { return $specified_foreign_key_name; } return $table_name . static::DEFAULT_FOREIGN_KEY_SUFFIX; } public static function factory($class_name) { $table_name = static::_get_table_name($class_name); $wrapper = ORMWrapper::for_table($table_name); $wrapper->set_class_name($class_name); $wrapper->use_id_column(static::_get_id_column_name($class_name)); return $wrapper; } protected function _has_one_or_many($associated_class_name, $foreign_key_name=null) { $base_table_name = static::_get_table_name(get_class($this)); $foreign_key_name = static::_build_foreign_key_name($foreign_key_name, $base_table_name); return static::factory($associated_class_name)->where($foreign_key_name, $this->id()); } protected function has_one($associated_class_name, $foreign_key_name=null) { return $this->_has_one_or_many($associated_class_name, $foreign_key_name); } protected function has_many($associated_class_name, $foreign_key_name=null) { return $this->_has_one_or_many($associated_class_name, $foreign_key_name); } protected function belongs_to($associated_class_name, $foreign_key_name=null) { $associated_table_name = static::_get_table_name($associated_class_name); $foreign_key_name = static::_build_foreign_key_name($foreign_key_name, $associated_table_name); $associated_object_id = $this->$foreign_key_name; return static::factory($associated_class_name)->where_id_is($associated_object_id); } protected function has_many_through($associated_class_name, $join_class_name=null, $key_to_base_table=null, $key_to_associated_table=null) { $base_class_name = get_class($this); if (is_null($join_class_name)) { $class_names = array($base_class_name, $associated_class_name); sort($class_names, SORT_STRING); $join_class_name = join("", $class_names); } $base_table_name = static::_get_table_name($base_class_name); $associated_table_name = static::_get_table_name($associated_class_name); $join_table_name = static::_get_table_name($join_class_name); $base_table_id_column = static::_get_id_column_name($base_class_name); $associated_table_id_column = static::_get_id_column_name($associated_class_name); $key_to_base_table = static::_build_foreign_key_name($key_to_base_table, $base_table_name); $key_to_associated_table = static::_build_foreign_key_name($key_to_associated_table, $associated_table_name); return static::factory($associated_class_name) ->select("{$associated_table_name}.*") ->join($join_table_name, array("{$associated_table_name}.{$associated_table_id_column}", '=', "{$join_table_name}.{$key_to_associated_table}")) ->where("{$join_table_name}.{$key_to_base_table}", $this->id()); } public function set_orm($orm) { $this->orm = $orm; } public function __get($property) { if (!is_object($this->orm)) { echo "<pre>"; debug_print_backtrace(); echo "</pre>"; } return $this->orm->get($property); } public function __set($property, $value) { $this->orm->set($property, $value); } public function __isset($property) { return $this->orm->__isset($property); } public function get($property) { return $this->orm->get($property); } public function set($property, $value) { $this->orm->set($property, $value); } public function is_dirty($property) { return $this->orm->is_dirty($property); } public function as_array() { $args = func_get_args(); return call_user_func_array(array($this->orm, 'as_array'), $args); } public function save() { return $this->orm->save(); } public function delete() { return $this->orm->delete(); } public function id() { return $this->orm->id(); } public function hydrate($data) { $this->orm->hydrate($data)->force_all_dirty(); } } class BDb { protected static $_namedDbs = array(); protected static $_namedDbConfig = array(); protected static $_defaultDbName = 'DEFAULT'; protected static $_currentDbName; protected static $_config = array('table_prefix'=>''); protected static $_tables = array(); protected static $_migration = array(); protected static $_uninstall = array(); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public static function connect($name=null) { if (!$name && static::$_currentDbName) { return BORM::get_db(); } if (is_null($name)) { $name = static::$_defaultDbName; } if ($name===static::$_currentDbName) { return BORM::get_db(); } if (!empty(static::$_namedDbs[$name])) { static::$_currentDbName = $name; static::$_config = static::$_namedDbConfig[$name]; BORM::set_db(static::$_namedDbs[$name], static::$_config); return BORM::get_db(); } $config = BConfig::i()->get($name===static::$_defaultDbName ? 'db' : 'db/named/'.$name); if (!$config) { throw new BException(BApp::t('Invalid or missing DB configuration: %s', $name)); } if (!empty($config['use'])) { static::connect($config['use']); return; } if (!empty($config['dsn'])) { $dsn = $config['dsn']; if (empty($config['dbname']) && preg_match('#dbname=(.*?)(;|$)#', $dsn, $m)) { $config['dbname'] = $m[1]; } } else { if (empty($config['dbname'])) { throw new BException(BApp::t("dbname configuration value is required for '%s'", $name)); } $engine = !empty($config['engine']) ? $config['engine'] : 'mysql'; $host = !empty($config['host']) ? $config['host'] : '127.0.0.1'; switch ($engine) { case "mysql": $dsn = "mysql:host={$host};dbname={$config['dbname']}"; break; default: throw new BException(BApp::t('Invalid DB engine: %s', $engine)); } } static::$_currentDbName = $name; BORM::configure($dsn); BORM::configure('username', !empty($config['username']) ? $config['username'] : 'root'); BORM::configure('password', !empty($config['password']) ? $config['password'] : ''); BORM::configure('logging', !empty($config['logging'])); BORM::set_db(null); BORM::setup_db(); static::$_namedDbs[$name] = BORM::get_db(); static::$_config = static::$_namedDbConfig[$name] = array( 'dbname' => !empty($config['dbname']) ? $config['dbname'] : null, 'table_prefix' => !empty($config['table_prefix']) ? $config['table_prefix'] : '', ); return BORM::get_db(); } public static function now() { return gmstrftime('%F %T'); } public static function run($sql) { $queries = preg_split("/;+(?=([^'|^\\\']*['|\\\'][^'|^\\\']*['|\\\'])*[^'|^\\\']*[^'|^\\\']$)/", $sql); $results = array(); foreach ($queries as $query){ if (strlen(trim($query)) > 0) { try { $results[] = BORM::get_db()->exec($query); } catch (Exception $e) { var_dump($e); exit; } } } return $results; } public static function transaction($connectionName=null) { if (!is_null($connectionName)) { BDb::connect($connectionName); } BORM::get_db()->beginTransaction(); } public static function commit($connectionName=null) { if (!is_null($connectionName)) { BDb::connect($connectionName); } BORM::get_db()->commit(); } public static function rollback($connectionName=null) { if (!is_null($connectionName)) { BDb::connect($connectionName); } BORM::get_db()->rollback(); } public static function t($tableName) { $a = explode('.', $tableName); $p = static::$_config['table_prefix']; return !empty($a[1]) ? $a[0].'.'.$p.$a[1] : $p.$a[0]; } public static function many_as_array($rows, $method='as_array', $fields=null, $maskInverse=false) { $res = array(); foreach ((array)$rows as $i=>$r) { if (!$r instanceof BModel) { echo "<pre>"; print_r($r); debug_print_backtrace(); exit; } $row = $r->$method(); if (!is_null($fields)) $row = BUtil::maskFields($row, $fields, $maskInverse); $res[$i] = $row; } return $res; } public static function where($conds, $or=false) { if (is_string($conds)) { return array($conds, array()); } $where = array(); $params = array(); if (is_array($conds)) { foreach ($conds as $f=>$v) { if (is_int($f)) { if (is_string($v)) { $where[] = '('.$v.')'; } elseif (is_array($v)) { $where[] = array_shift($v); $params = array_merge($params, $v); } else { throw new BException('Invalid token: '.print_r($v,1)); } } elseif ('AND'===$f) { list($w, $p) = static::where($v); $where[] = '('.$w.')'; $params = array_merge($params, $p); } elseif ('OR'===$f) { list($w, $p) = static::where($v, true); $where[] = '('.$w.')'; $params = array_merge($params, $p); } elseif ('NOT'===$f) { list($w, $p) = static::where($v); $where[] = 'NOT ('.$w.')'; $params = array_merge($params, $p); } elseif (is_array($v)) { $where[] = "({$f} IN (".str_pad('', sizeof($v)*2-1, '?,')."))"; $params = array_merge($params, $v); } elseif (is_null($v)) { $where[] = "({$f} IS NULL)"; } else { $where[] = "({$f}=?)"; $params[] = $v; } } return array(join($or ? " OR " : " AND ", $where), $params); } throw new BException("Invalid where parameter"); } public static function dbName() { if (!static::$_config) { throw new BException('No connection selected'); } return static::$_config['dbname']; } public static function ddlClearCache() { static::$_tables = array(); return $this; } public static function ddlTableExists($fullTableName) { $a = explode('.', $fullTableName); $dbName = empty($a[1]) ? static::dbName() : $a[0]; $tableName = empty($a[1]) ? $fullTableName : $a[1]; if (!isset(static::$_tables[$dbName])) { $tables = BORM::i()->raw_query("SHOW TABLES FROM `{$dbName}`", array())->find_many(); $field = "Tables_in_{$dbName}"; foreach ($tables as $t) { static::$_tables[$dbName][$t->$field] = array(); } } return isset(static::$_tables[$dbName][$tableName]); } public static function ddlFieldInfo($fullTableName, $fieldName=BNULL) { $a = explode('.', $fullTableName); $dbName = empty($a[1]) ? static::dbName() : $a[0]; $tableName = empty($a[1]) ? $fullTableName : $a[1]; if (!static::ddlTableExists($fullTableName)) { throw new BException(BApp::t('Invalid table name: %s', $fullTableName)); } $tableFields =& static::$_tables[$dbName][$tableName]['fields']; if (empty($tableFields)) { $fields = BORM::i()->raw_query("SHOW FIELDS FROM `{$dbName}`.`{$tableName}`", array())->find_many(); foreach ($fields as $f) { $tableFields[$f->Field] = $f; } } return BNULL===$fieldName ? $tableFields : (isset($tableFields[$fieldName]) ? $tableFields[$fieldName] : null); } public static function cleanForTable($table, $data) { $isObject = is_object($data); $result = array(); foreach ($data as $k=>$v) { if (BDb::ddlFieldInfo($table, $k)) { $result[$k] = $isObject ? $data->$k : $data[$k]; } } return $result; } public static function migrate($script='migrate.php', $moduleName=null) { if (is_null($moduleName)) { $moduleName = BModuleRegistry::currentModuleName(); } $module = BModuleRegistry::i()->module($moduleName); $dbName = $module->db_name ? $module->db_name : 'DEFAULT'; static::$_migration[$dbName][$moduleName]['script'] = $script; } public static function uninstall($script, $moduleName=null) { if (is_null($moduleName)) { $moduleName = BModuleRegistry::currentModuleName(); } static::$_uninstall[$moduleName]['script'] = $script; } public static function runMigrationScripts() { if (empty(static::$_migration)) { return; } return; $modReg = BModuleRegistry::i(); foreach (static::$_migration as $dbName=>$modules) { foreach ($modules as $modName=>&$m) { if (($version = $modReg->module($modName)->version)) { $m['code_version'] = $version; } else { unset($modules[$modName]); } } unset($m); if (!$modules) continue; BDb::connect($dbName); BDbModule::init(); $dbModules = BDbModule::i()->factory()->find_many(); foreach ($dbModules as $m) { $modules[$m->module_name]['schema_version'] = $m->schema_version; } foreach ($modules as $modName=>$mod) { $modReg->currentModule($modName); $script = $mod['script']; $module = $modReg->module($modName); if (is_callable($script)) { call_user_func($script); } elseif (is_file($module->root_dir.'/'.$script)) { include_once($module->root_dir.'/'.$script); } elseif (is_dir($module->root_dir.'/'.$script)) { } } } $modReg->currentModule(null); } public static function install($version, $callback) { $modName = BModuleRegistry::currentModuleName(); if (empty(static::$_migration[$modName]['code_version'])) { return false; } if (!empty(static::$_migration[$modName]['schema_version'])) { return true; } $mod = BDbModule::i()->create(array( 'module_name' => $modName, 'schema_version' => $version, 'last_upgrade' => BDb::now(), ))->save(); try { if (is_callable($callback)) { call_user_func($callback); } elseif (is_file($callback)) { include $callback; } elseif (is_string($callback)) { BDb::run($callback); } } catch (Exception $e) { $mod->delete(); throw $e; } static::$_migration[$modName]['schema_version'] = $version; return true; } public static function upgrade($fromVersion, $toVersion, $callback) { $modName = BModuleRegistry::currentModuleName(); if (empty(static::$_migration[$modName]['code_version'])) { return false; } if (empty(static::$_migration[$modName]['schema_version'])) { throw new BException(BApp::t("Can't upgrade, module schema doesn't exist yet: %s", BModuleRegistry::currentModuleName())); } $schemaVersion = static::$_migration[$modName]['schema_version']; if (version_compare($schemaVersion, $fromVersion, '>=') || version_compare($schemaVersion, $toVersion, '>')) { return true; } if (is_callable($callback)) { call_user_func($callback); } elseif (is_file($callback)) { include $callback; } elseif (is_string($callback)) { BDb::run($callback); } static::$_migration[$modName]['schema_version'] = $toVersion; BDbModule::i()->load($modName, 'module_name')->set(array( 'schema_version' => $toVersion, 'last_upgrade' => BDb::now(), ))->save(); return true; } public static function runUninstallScript($modName=null) { if (is_null($modName)) { $modName = BModuleRegistry::currentModuleName(); } if (empty(static::$_migration[$modName]['code_version'])) { return false; } if (empty(static::$_migration[$modName]['schema_version'])) { return true; } if (is_callable($callback)) { call_user_func($callback); } elseif (is_file($callback)) { include $callback; } elseif (is_string($callback)) { BDb::run($callback); } BDbModule::i()->load($modName, 'module_name')->delete(); return true; } } class BPDO extends PDO { protected static $_savepointTransactions = array("pgsql", "mysql"); protected $_transLevel = 0; public static function exception_handler($exception) { die('Uncaught exception: '. $exception->getMessage()); } public function __construct($dsn, $username='', $password='', $driver_options=array()) { set_exception_handler(array(__CLASS__, 'exception_handler')); parent::__construct($dsn, $username, $password, $driver_options); restore_exception_handler(); } protected function _nestable() { return in_array($this->getAttribute(PDO::ATTR_DRIVER_NAME), static::$_savepointTransactions); } public function beginTransaction() { if (!$this->_nestable() || $this->_transLevel == 0) { parent::beginTransaction(); } else { $this->exec("SAVEPOINT LEVEL{$this->_transLevel}"); } $this->_transLevel++; } public function commit() { $this->_transLevel--; if (!$this->_nestable() || $this->_transLevel == 0) { parent::commit(); } else { $this->exec("RELEASE SAVEPOINT LEVEL{$this->_transLevel}"); } } public function rollBack() { $this->_transLevel--; if (!$this->_nestable() || $this->_transLevel == 0) { parent::rollBack(); } else { $this->exec("ROLLBACK TO SAVEPOINT LEVEL{$this->_transLevel}"); } } } class BORM extends ORMWrapper { protected static $_instance; protected $_class_name = 'BModel'; protected $_readDbName; protected $_writeDbName; public static function i($new=false) { if ($new) { return new static(''); } if (!static::$_instance) { static::$_instance = new static(''); } return static::$_instance; } protected function _quote_identifier($identifier) { if ($identifier[0]=='(') { return $identifier; } return parent::_quote_identifier($identifier); } public static function get_config($key) { return !empty(static::$_config[$key]) ? static::$_config[$key] : null; } public static function setup_db() { static::_setup_db(); } protected static function _setup_db() { if (!is_object(static::$_db)) { $connection_string = static::$_config['connection_string']; $username = static::$_config['username']; $password = static::$_config['password']; $driver_options = static::$_config['driver_options']; $db = new BPDO($connection_string, $username, $password, $driver_options); $db->setAttribute(PDO::ATTR_ERRMODE, static::$_config['error_mode']); static::set_db($db); } } public static function set_db($db, $config=null) { if (!is_null($config)) { static::$_config = array_merge(static::$_config, $config); } static::$_db = $db; if (!is_null($db)) { static::_setup_identifier_quote_character(); } } public function set_rw_db_names($read, $write) { $this->_readDbName = $read; $this->_writeDbName = $write; return $this; } protected function _run() { BDb::connect($this->_readDbName); return parent::_run(); } public function select($column, $alias=null) { if (is_array($column)) { foreach ($column as $k=>$v) { $col = (!is_null($alias) ? $alias.'.' : '').$v; if (is_int($k)) { $this->select($col); } else { $this->select($col, $k); } } return $this; } return parent::select($column, $alias); } public function execute() { BDb::connect($this->_readDbName); $query = $this->_build_select(); static::_log_query($query, $this->_values); $statement = static::$_db->prepare($query); try { $statement->execute($this->_values); } catch (Exception $e) { echo $query; print_r($e); exit; } return $statement; } public function row_to_model($row) { return $this->_create_model_instance($this->_create_instance_from_row($row)); } public function iterate($callback) { $statement = $this->execute(); while ($row = $statement->fetch(PDO::FETCH_ASSOC)) { $model = $this->row_to_model($row); call_user_func($callback, $model); } return $this; } public function where_complex($conds, $or=false) { list($where, $params) = BDb::where($conds, $or); return $this->where_raw($where, $params); } public function find_many_assoc($key=null, $labelColumn=null, $options=array()) { $objects = $this->find_many(); $array = array(); $idColumn = !empty($key) ? $key : $this->_get_id_column_name(); foreach ($objects as $r) { $key = $r->$idColumn; if (!empty($options['key_lower'])) $key = strtolower($key); if (!empty($options['key_trim'])) $key = trim($key); $array[$key] = is_null($labelColumn) ? $r : $r->$labelColumn; } return $array; } public function is_dirty($key=null) { return is_null($key) ? !empty($this->_dirty_fields) : isset($this->_dirty_fields[$key]); } public function set($key, $value) { if (!array_key_exists($key, $this->_data) || $this->_data[$key] !== $value) { $this->_dirty_fields[$key] = $value; } $this->_data[$key] = $value; } public function save() { BDb::connect($this->_writeDbName); $this->_dirty_fields = BDb::cleanForTable($this->_table_name, $this->_dirty_fields); return parent::save(); } public function delete() { BDb::connect($this->_writeDbName); return parent::delete(); } public function raw_query($query, $parameters) { if (preg_match('#^\s*(SELECT|SHOW)#i', $query)) { BDb::connect($this->_readDbName); } else { BDb::connect($this->_writeDbName); } return parent::raw_query($query, $parameters); } protected static function _get_table_name($class_name) { return BDb::t(parent::_get_table_name($class_name)); } public function paginate($r=null, $d=array()) { if (is_null($r)) { $r = BRequest::i()->get(); } $d = (array)$d; if (!empty($r['sc']) && empty($r['s']) && empty($r['sd'])) { list($r['s'], $r['sd']) = explode('|', $r['sc']); } if (!empty($r['s']) && !empty($d['s']) && is_array($d['s'])) { if (!in_array($r['s'], $d['s'])) $r['s'] = null; $d['s'] = null; } if (!empty($r['sd']) && $r['sd']!='asc' && $r['sd']!='desc') { $r['sd'] = null; } $s = array( 'p' => !empty($r['p']) && is_numeric($r['p']) ? $r['p'] : (isset($d['p']) ? $d['p'] : 1), 'ps' => !empty($r['ps']) && is_numeric($r['ps']) ? $r['ps'] : (isset($d['ps']) ? $d['ps'] : 100), 's' => !empty($r['s']) ? $r['s'] : (isset($d['s']) ? $d['s'] : ''), 'sd' => !empty($r['sd']) ? $r['sd'] : (isset($d['sd']) ? $d['sd'] : 'asc'), 'rs' => !empty($r['rs']) ? $r['rs'] : null, 'rc' => !empty($r['rc']) ? $r['rc'] : null, ); $s['sc'] = $s['s'].'|'.$s['sd']; $cntOrm = clone $this; $s['c'] = $cntOrm->count(); unset($cntOrm); $s['mp'] = ceil($s['c']/$s['ps']); if (($s['p']-1)*$s['ps']>$s['c']) $s['p'] = $s['mp']; if ($s['s']) $this->{'order_by_'.$s['sd']}($s['s']); $s['rs'] = isset($s['rs']) ? $s['rs'] : ($s['p']-1)*$s['ps']; $this->offset($s['rs'])->limit(!empty($s['rc']) ? $s['rc'] : $s['ps']); $rows = $this->find_many(); $s['rc'] = $rows ? sizeof($rows) : 0; if (!empty($d['as_array'])) { $rows = BDb::many_as_array($rows, is_string($d['as_array']) ? $d['as_array'] : 'as_array'); } if (!empty($d['format'])) { switch ($d['format']) { case 1: return $rows; case 2: $s['rows'] = $rows; return $s; } } return array('state'=>$s, 'rows'=>$rows); } public function __destruct() { unset($this->_data); } } class BModel extends Model { protected static $_dbName = 'DEFAULT'; protected static $_readDbName = null; protected static $_writeDbName = null; protected static $_tableName = null; protected static $_cacheAuto = false; protected static $_cacheFlags = array(); protected $_cache = array(); protected $_instanceCache = array(); public static function readDb() { return BDb::connect(static::$_readDbName ? static::$_readDbName : static::$_dbName); } public static function writeDb() { return BDb::connect(static::$_writeDbName ? static::$_writeDbName : static::$_dbName); } public static function factory($class_name=null) { if (is_null($class_name)) { $class_name = get_called_class(); } $class_name = BClassRegistry::i()->className($class_name); static::readDb(); $table_name = static::_get_table_name($class_name); $wrapper = BORM::for_table($table_name); $wrapper->set_class_name($class_name); $wrapper->use_id_column(static::_get_id_column_name($class_name)); $wrapper->set_rw_db_names( static::$_readDbName ? static::$_readDbName : static::$_dbName, static::$_writeDbName ? static::$_writeDbName : static::$_dbName ); return $wrapper; } public static function orm() { return static::i()->factory(); } public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(get_called_class(), $args, !$new); } public function set($key, $value=null, $flag=false) { if (is_array($key)) { foreach ($key as $k=>$v) { parent::set($k, $v); } } else { if (true===$flag) { $oldValue = $this->get($key); if (is_array($oldValue)) { $oldValue[] = $value; $value = $oldValue; } else { $value += $oldValue; } } if (!is_null($flag) || is_null($this->get($key))) { parent::set($key, $value); } } return $this; } public function add($key, $increment=1) { return $this->set($key, $increment, true); } public static function create($data=null) { $record = static::i()->factory()->create($data); $record->afterCreate(); return $record; } public function afterCreate() { return $this; } public static function load($id, $field=null) { if (is_null($field)) { $field = static::_get_id_column_name(get_called_class()); } $key = $id; if (!empty(static::$_cacheFlags[$field]['key_lower'])) $key = strtolower($key); if (!empty(static::i()->_cache[$field][$id])) return static::i()->_cache[$field][$key]; $orm = static::i()->factory(); if (is_array($id)) { $record = $orm->where_complex($id)->find_one(); } elseif (is_null($field)) { $record = $orm->find_one($id); } else { $record = $orm->where($field, $id)->find_one(); } if ($record) { $record->afterLoad(); if (static::$_cacheAuto===true || is_array(static::$_cacheAuto) && in_array($field, static::$_cacheAuto)) { $record->cacheStore(); } } return $record; } public function afterLoad() { return $this; } public function afterLoadAll($arr) { foreach ($arr as $r) { $r->afterLoad(); } return $this; } public function cacheClear() { static::i()->_cache = array(); return $this; } public function cachePreload($where=null, $field='id', $sort=null) { $cache =& static::i()->_cache; $orm = $this->factory(); if ($where) $orm->where_complex($where); if ($sort) $orm->order_by_asc($sort); $options = !empty(static::$_cacheFlags[$field]) ? static::$_cacheFlags[$field] : array(); $cache[$field] = $orm->find_many_assoc($field, null, $options); return $this; } public function cachePreloadFrom($collection, $fk='id', $lk='id') { if (!$collection) return $this; $keys = array(); $keyLower = !empty(static::$_cacheFlags[$lk]['key_lower']); foreach ($collection as $r) { $key = null; if (is_object($r)) { $key = $r->$fk; } elseif (is_array($r)) { $key = isset($r[$fk]) ? $r[$fk] : null; } elseif (is_scalar($r)) { $key = $r; } if (empty($key)) continue; if ($keyLower) $key = strtolower($key); if (!empty(static::i()->_cache[$lk][$key])) continue; $keys[$key] = 1; } if ($keys) $this->cachePreload(array($lk=>array_keys($keys)), $lk); return $this; } public function cacheCopy($toKey, $fromKey='id') { $cache =& static::i()->_cache; $lower = !empty(static::$_cacheFlags[$toKey]['key_lower']); foreach ($cache[$fromKey] as $r) { $key = $r->$toKey; if ($lower) $key = strtolower($key); $cache[$toKey][$key] = $r; } return $this; } public function cacheSaveDirty() { foreach (static::i()->_cache['id'] as $c) { if ($c->is_dirty()) $c->save(); } return $this; } public function cacheFetch($field='id', $key=null) { $cache = static::i()->_cache; if (empty($cache[$field])) return null; if (is_null($key)) return $cache[$field]; if (!empty(static::$_cacheFlags[$field]['key_lower'])) $key = strtolower($key); return !empty($cache[$field][$key]) ? $cache[$field][$key] : null; } public function cacheStore($field='id', $collection=null) { $cache =& static::i()->_cache; if ($collection) { foreach ($collection as $r) { $r->cacheStore($field); } return $this; } if (is_array($field)) { foreach ($field as $k) { $this->cacheStore($k); } return $this; } $key = $this->$field; if (!empty(static::$_cacheFlags[$field]['key_lower'])) $key = strtolower($key); $cache[$field][$key] = $this; return $this; } public function beforeSave() { return true; } public function is_dirty($property=null) { return $this->orm->is_dirty($property); } public function save() { if (!$this->beforeSave()) { return $this; } parent::save(); $this->afterSave(); if (static::$_cacheAuto) { $this->cacheStore(); } return $this; } public function afterSave() { return $this; } public function beforeDelete() { return true; } public function delete() { if (!$this->beforeDelete()) { return $this; } if (($cache =& static::i()->_cache)) { foreach ($cache as $k=>$cache) { $key = $this->$k; if (!empty(static::$_cacheFlags[$k]['key_lower'])) $key = strtolower($key); unset($cache[$k][$key]); } } parent::delete(); return $this; } public static function run_sql($sql, $params=array()) { return static::writeDb()->prepare($sql)->execute((array)$params); } public static function table() { if (!static::$_tableName) { static::$_tableName = BDb::t(static::_get_table_name(get_called_class())); } return static::$_tableName; } public static function update_many(array $data, $where, $p=array()) { $update = array(); $params = array(); foreach ($data as $k=>$v) { $update[] = "`{$k}`=?"; $params[] = $v; } if (is_array($where)) { list($where, $p) = BDb::where($where); } return static::run_sql("UPDATE ".static::table()." SET ".join(', ', $update) ." WHERE {$where}", array_merge($params, $p)); } public static function delete_many($where, $params=array()) { if (is_array($where)) { list($where, $params) = BDb::where($where); } return static::run_sql("DELETE FROM ".static::table()." WHERE {$where}", $params); } public function as_array(array $objHashes=array()) { $objHash = spl_object_hash($this); if (!empty($objHashes[$objHash])) { return "*** RECURSION: ".get_class($this); } $objHashes[$objHash] = 1; $data = parent::as_array(); foreach ($data as $k=>$v) { if ($v instanceof Model) { $data[$k] = $v->as_array(); } elseif (is_array($v) && current($v) instanceof Model) { foreach ($v as $k1=>$v1) { $data[$k][$k1] = $v1->as_array($objHashes); } } } return $data; } public function instanceCache($key, $value=BNULL) { if (BNULL===$value) { return isset($this->_instanceCache[$key]) ? $this->_instanceCache[$key] : null; } $this->_instanceCache[$key] = $value; return $this; } public function relatedModel($modelClass, $idValue, $autoCreate=false, $cacheKey=null) { $cacheKey = $cacheKey ? $cacheKey : $modelClass; $model = $this->instanceCache($cacheKey); if (is_null($model)) { if (is_array($idValue)) { $model = $modelClass::i()->factory()->where_complex($idValue)->find_one(); if ($model) $model->afterLoad(); } else { $model = $modelClass::i()->load($idValue); } if ($autoCreate && !$model) { if (is_array($idValue)) { $model = $modelClass::i()->create($idValue); } else { $model = $modelClass::i()->create(array($foreignIdField=>$idValue)); } } $this->instanceCache($cacheKey, $model); } return $model; } public function relatedCollection($modelClass, $where) { } public function childById($var, $id, $idField='id') { $collection = $this->$var; if (!$collection) return null; foreach ($collection as $k=>$v) { if ($v->$idField==$id) return $v; } return null; } public function __destruct() { unset($this->_cache, $this->_instanceCache); } }  class BModuleRegistry extends BClass { protected $_modules = array(); protected static $_currentModuleName = BNULL; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function module($modName, $params=BNULL) { if (BNULL===$params) { return isset($this->_modules[$modName]) ? $this->_modules[$modName] : null; } if (is_callable($params)) { $params = array('bootstrap'=>array('callback'=>$params)); } else { $params = (array)$params; } $params['name'] = $modName; if (!empty($this->_modules[$modName])) { $rootDir = $this->_modules[$modName]->root_dir; $file = $this->_modules[$modName]->bootstrap['file']; throw new BException(BApp::t('Module is already registered: %s (%s)', array($modName, $rootDir.'/'.$file))); } if (empty($params['bootstrap']['callback'])) { BApp::log('Missing bootstrap information, skipping module: %s', $modName); return $this; } if (empty($params['bootstrap']['file'])) { $params['bootstrap']['file'] = null; } if (empty($params['root_dir'])) { $params['root_dir'] = '.'; } if (empty($params['view_root_dir'])) { $params['view_root_dir'] = '.'; } if (empty($params['base_url'])) { $params['base_url'] = BApp::baseUrl(); } $this->_modules[$modName] = BModule::i(true, $params); return $this; } public function scan($source) { if (substr($source, -5)!=='.json') { $source .= '/manifest.json'; } $manifests = glob($source); if (!$manifests) { return $this; } foreach ($manifests as $file) { $json = file_get_contents($file); $manifest = BUtil::fromJson($json); if (empty($manifest['modules'])) { throw new BException(BApp::t("Could not read manifest file: %s", $file)); } $basePath = !empty($manifest['base_path']) ? $manifest['base_path'] : dirname($file); $rootDir = dirname(realpath($file)); foreach ($manifest['modules'] as $modName=>$params) { $params['name'] = $modName; $modRootDir = (!empty($params['root_dir']) ? $params['root_dir'] : ''); $params['root_dir'] = BUtil::normalizePath($rootDir.'/'.$modRootDir); $params['view_root_dir'] = $params['root_dir']; $params['base_url'] = BUtil::normalizePath(BApp::baseUrl().'/'.$basePath.'/'.$modRootDir); $this->module($modName, $params); } } return $this; } public function checkDepends() { $config = BConfig::i(); $reqModules = (array)$config->get('bootstrap/modules'); foreach ($this->_modules as $modName=>$mod) { foreach ($mod->depends as &$dep) { if (is_string($dep)) { $dep = array('name'=>$dep); } } if ((empty($reqModules) || in_array($modName, $reqModules)) && !empty($mod->depends)) { foreach ($mod->depends as &$dep) { if (!empty($this->_modules[$dep['name']])) { if (!empty($dep['version'])) { $depVer = $dep['version']; if (!empty($depVer['from']) && version_compare($depMod->version, $depVer['from'], '<') || !empty($depVer['to']) && version_compare($depMod->version, $depVer['to'], '>') || !empty($depVer['exclude']) && in_array($depMod->version, (array)$depVer['exclude']) ) { $dep['error'] = array('type'=>'version'); } } $mod->parents[] = $dep['name']; $this->_modules[$dep['name']]->children[] = $modName; if (!empty($reqModules)) { BConfig::i()->add(array('bootstrap'=>array('depends'=>array($dep['name'])))); } } else { $dep['error'] = array('type'=>'missing'); } } unset($dep); } } if (!empty($reqModules)) { foreach ($reqModules as $modName) { if (empty($this->_modules[$modName])) { throw new BException('Invalid module name: '.$modName); } } } foreach ($this->_modules as $modName=>$mod) { foreach ($mod->depends as &$dep) { if (!empty($dep['error']) && empty($dep['error']['propagated'])) { $this->propagateDepends($modName, $dep); } } unset($dep); } return $this; } public function propagateDepends($modName, &$dep) { $this->_modules[$modName]->error = 'depends'; $dep['error']['propagated'] = true; if (!empty($this->_modules[$modName]->depends)) { foreach ($this->_modules[$modName]->depends as &$subDep) { if (empty($subDep['error'])) { $subDep['error'] = array('type'=>'parent'); $this->propagateDepends($dep['name'], $subDep); } } unset($subDep); } return $this; } public function sortDepends() { $modules = $this->_modules; $rootModules = array(); foreach ($modules as $modName=>$mod) { if (empty($mod->parents)) { $rootModules[] = $mod; } } $sorted = array(); while ($modules) { if (!$rootModules) return false; $n = array_pop($rootModules); $sorted[$n->name] = $n; for ($i = count($n->children)-1; $i>=0; $i--) { $childModule = $modules[$n->children[$i]]; unset($n->children[$i]); unset($childModule->parents[array_search($n->name, $childModule->parents)]); if (!$childModule->parents) array_push($rootModules, $childModule); } unset($modules[$n->name]); } $this->_modules = $sorted; return $this; } public function bootstrap() { $this->checkDepends(); $this->sortDepends(); $config = BConfig::i()->get('bootstrap'); foreach ($this->_modules as $mod) { if (!empty($mod->error)) { BApp::log($mod->name.': '.$mod->error); continue; } if (!empty($config['modules']) && !in_array($mod->name, (array)$config['modules']) && !empty($config['depends']) && !in_array($mod->name, $config['depends']) ) { continue; } $this->currentModule($mod->name); if (!empty($mod->bootstrap['file'])) { require (BUtil::normalizePath($mod->root_dir.'/'.$mod->bootstrap['file'])); } BApp::log('Start bootstrap for %s', array($mod->name)); call_user_func($mod->bootstrap['callback']); BApp::log('End bootstrap for %s', array($mod->name)); } BModuleRegistry::i()->currentModule(null); return $this; } public function currentModule($name=BNULL) { if (BNULL===$name) { return static::$_currentModuleName ? $this->module(static::$_currentModuleName) : false; } static::$_currentModuleName = $name; return $this; } static public function currentModuleName() { return static::$_currentModuleName; } public function debug() { return $this->_modules; } } class BModule extends BClass { public $name; public $bootstrap; public $version; public $db_name; public $root_dir; public $autoload_root_dir; public $autoload_filename_cb; public $view_root_dir; public $base_url; public $depends = array(); public $parents = array(); public $children = array(); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct(array $args) { foreach ($args as $k=>$v) { $this->$k = $v; } } public function autoload($rootDir='', $callback=null) { $this->autoload_root_dir = rtrim((!$rootDir || $rootDir[0]!=='/' && $rootDir[1]!==':' ? $this->root_dir.'/' : '').$rootDir, '/'); $this->autoload_filename_cb = $callback; spl_autoload_register(array($this, 'autoloadCallback'), false); return $this; } public function autoloadCallback($class) { if ($this->autoload_filename_cb) { $file = call_user_func($this->autoload_filename_cb, $class); } else { $file = str_replace('_', '/', $class).'.php'; } if ($file) { if ($file[0]!=='/' && $file[1]!==':') { $file = $this->autoload_root_dir.'/'.$file; } include ($file); } } } class BDbModule extends BModel { protected static $_table = 'buckyball_module'; public static function init() { $table = BDb::t(static::$_table); BDb::connect(); if (!BDb::ddlTableExists($table)) { BDb::run("
CREATE TABLE {$table} (
id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
module_name VARCHAR(100) NOT NULL,
schema_version VARCHAR(20),
last_upgrade DATETIME,
UNIQUE (module_name)
) ENGINE=INNODB;
            "); } BDbModuleConfig::init(); } } class BDbModuleConfig extends BModel { protected static $_table = 'buckyball_module_config'; public static function init() { $table = BDb::t(static::$_table); $modTable = BDb::t('buckyball_module'); if (!BDb::ddlTableExists($table)) { BDb::run("
CREATE TABLE {$table} (
id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
module_id INT UNSIGNED NOT NULL,
`key` VARCHAR(100),
`value` TEXT,
UNIQUE (module_id, `key`),
CONSTRAINT `FK_{$modTable}` FOREIGN KEY (`module_id`) REFERENCES `{$modTable}` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=INNODB;
            "); } } }  class BRequest extends BClass { protected $_params = array(); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { $this->stripMagicQuotes(); } public function ip() { return !empty($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : null; } public function serverIp() { return !empty($_SERVER['SERVER_ADDR']) ? $_SERVER['SERVER_ADDR'] : null; } public function serverName() { return !empty($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : null; } public function https() { return !empty($_SERVER['HTTPS']); } public function xhr() { return !empty($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH']=='XMLHttpRequest'; } public function method() { return !empty($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : 'GET'; } public function webRoot() { return !empty($_SERVER['SCRIPT_NAME']) ? dirname($_SERVER['SCRIPT_NAME']) : null; } public function baseUrl() { return ($this->https() ? 'https' : 'http').'://'.$this->serverName().$this->webRoot(); } public function path($offset, $length=BNULL) { if (empty($_SERVER['PATH_INFO'])) { return null; } $path = explode('/', ltrim($_SERVER['PATH_INFO'], '/')); if (BNULL===$length) { return isset($path[$offset]) ? $path[$offset] : null; } return join('/', array_slice($path, $offset, true===$length ? null : $length)); } public function rawPath() { return !empty($_SERVER['PATH_INFO']) ? $_SERVER['PATH_INFO'] : '/'; } public function get($key=null) { return is_null($key) ? $_GET : (isset($_GET[$key]) ? $_GET[$key] : null); } public function rawGet() { return !empty($_SERVER['QUERY_STRING']) ? $_SERVER['QUERY_STRING'] : ''; } public function post($key=null) { return is_null($key) ? $_POST : (isset($_POST[$key]) ? $_POST[$key] : null); } public function rawPost() { $post = file_get_contents('php://input'); return $post; } public function json($asObject=false) { return BUtil::fromJson($this->rawPost(), $asObject); } public function request($key=null) { return is_null($key) ? $_REQUEST : (isset($_REQUEST[$key]) ? $_REQUEST[$key] : null); } public function cookie($name, $value=BNULL, $lifespan=null, $path=null, $domain=null) { if (BNULL===$value) { return isset($_COOKIE[$name]) ? $_COOKIE[$name] : null; } if (is_null($value) || false===$value) { return $this->cookie($name, '', -1000); } $config = BConfig::i()->get('cookie'); $lifespan = !is_null($lifespan) ? $lifespan : $config['timeout']; $path = !is_null($path) ? $path : $config['path']; $domain = !is_null($domain) ? $domain : $config['domain']; setcookie($name, $value, time()+$lifespan, $path, $domain); return $this; } public function referrer($default=null) { return !empty($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : $default; } public function initParams(array $params) { $this->_params = $params; return $this; } public function params($key=BNULL) { return BNULL===$key ? $this->_params : (isset($this->_params[$key]) ? $this->_params[$key] : null); } public function sanitize($data, $config, $trim=true) { $data = (array)$data; if ($trim) { $data = array_intersect_key($data, $config); } foreach ($data as $k=>&$v) { $filter = is_array($config[$k]) ? $config[$k][0] : $config[$k]; $v = $this->sanitizeOne($v, $filter); } unset($v); foreach ($config as $k=>$c) { if (!isset($data[$k])) { $data[$k] = is_array($c) && isset($c[1]) ? $c[1] : null; } } return $data; } public function sanitizeOne($v, $filter) { if (is_array($v)) { foreach ($v as $k=>&$v1) { $v1 = $this->sanitizeOne($v1, $filter); } unset($v1); return $v; } if (!is_array($filter)) { $filter = explode('|', $filter); } foreach ($filter as $f) { if (strpos($f, ':')) { list($f, $p) = explode(':', $f, 2); } else { $p = null; } switch ($f) { case 'int': $v = (int)$v; break; case 'positive': $v = $v>0 ? $v : null; break; case 'float': $v = (float)$v; break; case 'trim': $v = trim($v); break; case 'nohtml': $v = htmlentities($v, ENT_QUOTES); break; case 'plain': $v = htmlentities($v, ENT_NOQUOTES); break; case 'upper': $v = strtoupper($v); break; case 'lower': $v = strtolower($v); break; case 'ucwords': $v = ucwords($v); break; case 'ucfirst': $v = ucfirst($v); break; case 'urle': $v = urlencode($v); break; case 'urld': $v = urldecode($v); break; case 'alnum': $p = !empty($p)?$p:'_'; $v = preg_replace('#[^a-z0-9'.$p.']#i', '', $v); break; case 'regex': case 'regexp': $v = preg_replace($p, '', $v); break; case 'date': $v = date('Y-m-d', strtotime($v)); break; case 'datetime': $v = date('Y-m-d H:i:s', strtotime($v)); break; case 'gmdate': $v = gmdate('Y-m-d', strtotime($v)); break; case 'gmdatetime': $v = gmdate('Y-m-d H:i:s', strtotime($v)); break; } } return $v; } public function stripMagicQuotes() { static $alreadyRan = false; if (get_magic_quotes_gpc() && !$alreadyRan) { $process = array(&$_GET, &$_POST, &$_COOKIE, &$_REQUEST); while (list($key, $val) = each($process)) { foreach ($val as $k => $v) { unset($process[$key][$k]); if (is_array($v)) { $process[$key][stripslashes($k)] = $v; $process[] = &$process[$key][stripslashes($k)]; } else { $process[$key][stripslashes($k)] = stripslashes($v); } } } unset($process); $alreadyRan = true; } return $this; } } class BResponse extends BClass { protected $_contentType = 'text/html'; protected $_contentPrefix; protected $_contentSuffix; protected $_content; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public static function q($str) { if (is_null($str)) { return ''; } if (!is_scalar($str)) { var_dump($str); return ' ** ERROR ** '; } return htmlspecialchars($str); } public function cookie($name, $value=null, $lifespan=null, $path=null, $domain=null) { BRequest::i()->cookie($name, $value, $lifespan, $path, $domain); return $this; } public function set($content) { $this->_content = $content; return $this; } public function add($content) { $this->_content = (array)$this->_content+(array)$content; return $this; } public function contentType($type=BNULL) { if (BNULL===$type) { return $this->_contentType; } $this->_contentType = $type; return $this; } public function contentPrefix($string=BNULL) { if (BNULL===$string) { return $this->_contentPrefix; } $this->_contentPrefix = $string; return $this; } public function contentSuffix($string=BNULL) { if (BNULL===$string) { return $this->_contentSuffix; } $this->_contentSuffix = $string; return $this; } public function json($data) { $this->contentType('application/json')->set(BUtil::toJson($data))->render(); } public function sendFile($source, $filename=null) { BSession::i()->close(); header('Pragma: public'); header('Cache-Control: must-revalidate, post-check=0, pre-check=0'); header('Content-Type: application/octet-stream'); header('Content-Length: ' . filesize($source)); header('Last-Modified: ' . date('r')); header('Content-Disposition: attachment; filename=' . $filename ? $filename : basename($source)); $fs = fopen($source, 'rb'); $fd = fopen('php://output', 'wb'); while (!feof($fs)) fwrite($fd, fread($fs, 8192)); fclose($fs); fclose($fd); $this->shutdown(__METHOD__); } public function sendContent($content, $filename='download.txt') { BSession::i()->close(); header('Pragma: public'); header('Cache-Control: must-revalidate, post-check=0, pre-check=0'); header('Content-Type: application/octet-stream'); header('Content-Length: ' . strlen($content)); header('Last-Modified: ' . date('r')); header('Content-Disposition: attachment; filename=' . $filename); echo $content; $this->shutdown(__METHOD__); } public function status($status, $message=null, $output=true) { if (is_null($message)) { switch ((int)$status) { case 301: $message = 'Moved Permanently'; break; case 302: $message = 'Moved Temporarily'; break; case 303: $message = 'See Other'; break; case 401: $message = 'Unauthorized'; break; case 404: $message = 'Not Found'; break; case 503: $message = 'Service Unavailable'; break; default: $message = 'Unknown'; } } header("HTTP/1.0 {$status} {$message}"); header("Status: {$status} {$message}"); if ($output) { $this->output(); } return $this; } public function output($type=null) { BEventRegistry::i()->dispatch('BResponse::output.before'); if (!is_null($type)) { $this->contentType($type); } BSession::i()->close(); header('Content-Type: '.$this->_contentType); if ($this->_contentType=='application/json') { $this->_content = is_string($this->_content) ? $this->_content : BUtil::toJson($this->_content); } elseif (is_null($this->_content)) { $this->_content = BLayout::i()->render(); } echo $this->_contentPrefix; print_r($this->_content); echo $this->_contentSuffix; BEventRegistry::i()->dispatch('BResponse::output.after'); if ($this->_contentType=='text/html' && BDebug::i()->mode()=='debug' && !BRequest::i()->xhr()) { echo "<hr>DELTA: ".BDebug::i()->delta().', PEAK: '.memory_get_peak_usage(true).', EXIT: '.memory_get_usage(true); } $this->shutdown(__METHOD__); } public function render() { $this->output(); } public function redirect($url, $status=302) { BSession::i()->close(); $this->status($status, null, false); header("Location: {$url}"); $this->shutdown(__METHOD__); } public function shutdown($lastMethod=null) { BEventRegistry::i()->dispatch('BResponse::shutdown', array('last_method'=>$lastMethod)); exit; } } class BRouteNode { protected $_children = array(); protected $_observers = array(); protected $_match; public function child($type, $key=null, $create=false) { if (is_null($key)) { return !empty($this->_children[$type]) ? $this->_children[$type] : array(); } if (empty($this->_children[$type][$key])) { if ($create) { $node = new BRouteNode(); $this->_children[$type][$key] = $node; } else { return null; } } return $this->_children[$type][$key]; } public function children() { return $this->_children; } public function observe($callback, $args=null, $multiple=false) { $observer = new BRouteObserver(); $observer->callback = $callback; if (($moduleName = BModuleRegistry::currentModuleName())) { $observer->moduleName = $moduleName; } if (!empty($args)) { $observer->args = $args; } if ($multiple || empty($this->_observers)) { $this->_observers[] = $observer; } else { $this->_observers[0] = BUtil::arrayMerge($this->_observers[0], $observer); } return $this; } public function validObserver() { foreach ($this->_observers as $o) { if (!$o->skip) return $o; } return null; } public function match($data=null) { if (is_null($data)) { return $this->_match; } $this->_match = $data; if (!empty($data['action'])) { $data['observer']->callback .= '.'.$data['action']; } return $this; } public function __destruct() { unset($this->_observers, $this->_children, $this->_match); } } class BRouteObserver { public $callback; public $moduleName; public $args; public $skip; } class BFrontController extends BClass { protected $_routes = array(); protected $_defaultRoutes = array('default'=>array('callback'=>array('BActionController', 'noroute'))); protected $_currentRoute; protected $_routeTree = array(); protected $_urlTemplates = array(); protected $_controllerName; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function saveRoute($route, $callback=null, $args=null, $multiple=false) { list($method, $route) = explode(' ', $route, 2); $route = ltrim($route, '/'); if (!isset($this->_routeTree[$method])) { $this->_routeTree[$method] = new BRouteNode(); } $node = $this->_routeTree[$method]; $routeArr = explode('/', $route); foreach ($routeArr as $r) { if ($r!=='' && ($r[0]===':' || $r[0]==='*' || $r[0]==='.')) { $node = $node->child($r[0], $r, true); } else { $node = $node->child('/', $r==='' ? '__EMPTY__' : $r, true); } } $node->observe($callback, $args, $multiple); return $this; } public function findRoute($route=null) { if (is_null($route)) { $route = BRequest::i()->rawPath(); } if (strpos($route, ' ')===false) { $method = BRequest::i()->method(); } else { list($method, $route) = explode(' ', $route, 2); } if (empty($this->_routeTree[$method])) { return null; } $requestArr = $route=='' ? array('') : explode('/', ltrim($route, '/')); $node = $this->_routeTree[$method]; $routeName = array($method.' '); $params = array(); $dynAction = null; $observer = null; foreach ($requestArr as $i=>$r) { $r1 = $r==='' ? '__EMPTY__' : $r; $nextR = isset($requestArr[$i+1]) ? $requestArr[$i+1] : null; $nextR = $nextR==='' ? '__EMPTY__' : $nextR; if ($r1==='__EMPTY__' && is_null($nextR) && ($child = $node->child('/', $r1)) && ($observer = $child->validObserver()) ) { $node = $child; $routeName[] = $r; break; } if (($children = $node->child('*'))) { foreach ($children as $k=>$n) { if (!($observer = $n->validObserver())) continue; $params[substr($k, 1)] = join('/', array_slice($requestArr, $i)); $node = $n; break 2; } } if (($children = $node->child('.'))) { foreach ($children as $k=>$n) { if (($n->child(':') || $n->child('/', $nextR)) || (is_null($nextR) && ($observer = $n->validObserver())) ) { $node = $n; $dynAction = $r; continue 2; } } } if (($children = $node->child(':'))) { foreach ($children as $k=>$n) { if ((!is_null($nextR) && ($n->child(':') || $n->child('/', $nextR))) || (is_null($nextR) && ($observer = $n->validObserver())) ) { $params[substr($k, 1)] = $r; $node = $n; continue 2; } } } if (!$dynAction && ($child = $node->child('/', $r1))) { $node = $child; $routeName[] = $r; if (is_null($nextR)) { if (!($observer = $node->validObserver())) { return null; } break; } continue; } return null; } $node->match(array('route_name'=>join('/', $routeName), 'params'=>$params, 'observer'=>$observer, 'action'=>$dynAction)); return $node; } public function route($route, $callback=null, $args=null, $name=null) { if (is_array($route)) { foreach ($route as $a) { if (is_null($callback)) { $this->route($a[0], $a[1], isset($a[2])?$a[2]:null, isset($a[3])?$a[3]:null); } else { $this->route($a, $callback, $args); } } return; } $this->saveRoute($route, $callback, $args, false); $this->_routes[$route] = $callback; if (!is_null($name)) { $this->_urlTemplates[$name] = $route; } return $this; } public function defaultRoute($callback, $args=null, $name='default') { $route = array('callback'=>$callback, 'args'=>$args); if ($name) { $this->_defaultRoutes[$name] = $route; } else { $this->_defaultRoutes[] = $route; } return $this; } public function currentRoute() { return $this->_currentRoute; } public function dispatch($route=null) { $attempts = 0; $forward = true; while (($attempts++<100) && $forward) { if (true===$forward) { $node = $this->findRoute($route); $this->_currentRoute = $node; $match = $node->match(); $observer = $match['observer']; if (!$node || !$observer) { $params = array(); $callback = $this->_defaultRoutes['default']['callback']; } else { $callback = $observer->callback; $params = (array)$match['params']; } $args = (array)$observer->args; if (is_string($callback)) { $r = explode('.', $callback); if (sizeof($r)==2) $callback = $r; } if (is_callable($callback)) { call_user_func_array($callback, $args); return; } $controllerName = $callback[0]; $actionName = $callback[1]; $request = BRequest::i(); if ($observer->moduleName) { BModuleRegistry::i()->currentModule($observer->moduleName); } } if (is_array($forward)) { list($actionName, $forwardControllerName, $params) = $forward; if ($forwardControllerName) { $controllerName = $forwardControllerName; } } $request->initParams($params); $controller = BClassRegistry::i()->instance($controllerName, array(), true); $controller->dispatch($actionName, $args); $forward = $controller->forward(); } if ($attempts==100) { throw new BException(BApp::t('Reached 100 route iterations: %s', print_r($callback,1))); } } } class BActionController extends BClass { public $params = array(); protected $_action; protected $_forward; protected $_actionMethodPrefix = 'action_'; public function view($viewname) { return BLayout::i()->view($viewname); } public function dispatch($actionName, $args=array()) { $this->_action = $actionName; $this->_forward = null; if (!$this->beforeDispatch($args)) { return $this; } elseif (!$this->authorize($args) && $actionName!=='unauthorized') { $this->forward('unauthorized'); return $this; } if (!$this->forward()) { $this->tryDispatch($actionName, $args); } if (!$this->forward()) { $this->afterDispatch($args); } return $this; } public function tryDispatch($actionName, $args) { if (is_callable($actionName)) { try { call_user_func($actionName); } catch (DActionException $e) { $this->sendError($e->getMessage()); } catch (Exception $e) { echo "<pre>"; print_r($e); echo "</pre>"; } return $this; } $actionMethod = $this->_actionMethodPrefix.$actionName; if (!is_callable(array($this, $actionMethod))) { $this->forward('noroute'); return $this; } try { $this->$actionMethod($args); } catch (DActionException $e) { $this->sendError($e->getMessage()); } catch (Exception $e) { echo "<pre>"; print_r($e); echo "</pre>"; } return $this; } public function tryNextRoute() { $front = BFrontController::i(); $match = $front->currentRoute()->match(); $match['observer']->skip = true; $this->forward(true); return $this; } public function forward($actionName=BNULL, $controllerName=null, array $params=array()) { if (BNULL===$actionName) { return $this->_forward; } if (true===$actionName) { $this->_forward = true; } else { $this->_forward = array($actionName, $controllerName, $params); } return $this; } public function authorize($args=array()) { return true; } public function beforeDispatch() { return true; } public function afterDispatch() { } public function sendError($message) { BResponse::i()->set($message)->status(503); } public function action_unauthorized() { BResponse::i()->set("Unauthorized")->status(401); } public function action_noroute() { BResponse::i()->set("Route not found")->status(404); } public function renderOutput() { BResponse::i()->output(); } }  class BLayout extends BClass { protected $_views = array(); protected $_mainViewName = 'main'; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function viewRootDir($rootDir) { $module = BModuleRegistry::i()->currentModule(); $isAbsPath = strpos($rootDir, '/')===0 || strpos($rootDir, ':')===1; $module->view_root_dir = $isAbsPath ? $rootDir : $module->root_dir.'/'.$rootDir; return $this; } public function allViews($rootDir, $prefix='') { $rootDir = BModuleRegistry::i()->currentModule()->root_dir.'/'.$rootDir; $this->viewRootDir($rootDir); $files = glob($rootDir.'/*'); if (!$files) { return $this; } for ($i=0; $i<count($files); $i++) { if (is_dir($files[$i])) { $add = glob($files[$i] . '/*'); $files = array_merge($files, $add); } } foreach ($files as $file) { if (preg_match('#^('.preg_quote($rootDir.'/', '#').')(.*)(\.php)$#', $file, $m)) { $this->view($prefix.$m[2], array('template'=>$m[2].$m[3])); } } return $this; } public function view($viewname, $params=BNULL, $reset=false) { if (is_array($viewname)) { foreach ($viewname as $i=>$view) { if (!is_numeric($i)) { throw new BException(BApp::t('Invalid argument: %s', print_r($viewname,1))); } $this->view($view[0], $view[1]); } return $this; } if (BNULL===$params) { if (!isset($this->_views[$viewname])) { return null; } return $this->_views[$viewname]; } if (empty($params['module_name']) && ($moduleName = BModuleRegistry::currentModuleName())) { $params['module_name'] = $moduleName; } if (!isset($this->_views[$viewname]) || !empty($params['view_class'])) { $this->_views[$viewname] = BView::i()->factory($viewname, $params); } else { $this->_views[$viewname]->param($params); } return $this; } public function mainView($viewname=BNULL) { if (BNULL===$viewname) { return $this->_mainViewName ? $this->view($this->_mainViewName) : null; } if (empty($this->_views[$viewname])) { throw new BException(BApp::t('Invalid view name for main view: %s', $viewname)); } $this->_mainViewName = $viewname; return $this; } public function cloneView($from, $to=BNULL) { if (BNULL===$to) $to = $from.'-copy'; $this->_views[$to] = clone $this->_views[$from]; $this->_views[$to]->view_name = $to; return $this->_views[$to]; } public function dispatch($eventName, $routeName=null, $args=array()) { if (is_null($routeName)) { $route = BFrontController::i()->currentRoute(); if ($route && ($match = $route->match())) { $routeName = $match['route_name']; $args['route_name'] = $routeName; } } $result = BEventRegistry::i()->dispatch("BLayout::{$eventName}", $args); $routes = is_string($routeName) ? explode(',', $routeName) : (array)$routeName; foreach ($routes as $route) { $args['route_name'] = $route; $r2 = BEventRegistry::i()->dispatch("BLayout::{$eventName}: {$route}", $args); $result = BUtil::arrayMerge($result, $r2); } return $result; } public function render($routeName=null, $args=array()) { $this->dispatch('render.before', $routeName, $args); $mainView = $this->mainView(); if (!$mainView) { throw new BException(BApp::t('Main view not found: %s', $this->_mainViewName)); } $result = $mainView->render($args); $args['output'] =& $result; $this->dispatch('render.after', $routeName, $args); return $result; } public function debugPrintViews() { foreach ($this->_views as $viewname=>$view) { echo $viewname.':<pre>'; print_r($view); echo '</pre><hr>'; } } } class BView extends BClass { static protected $_defaultClass = __CLASS__; protected $_params; static public function factory($viewname, array $params) { $params['view_name'] = $viewname; $className = !empty($params['view_class']) ? $params['view_class'] : static::$_defaultClass; $view = BClassRegistry::i()->instance($className, $params); return $view; } public function __construct(array $params) { $this->_params = $params; } public function param($key=BNULL, $value=BNULL) { if (BNULL===$key) { return $this->_params; } if (is_array($key)) { foreach ($key as $k=>$v) { $this->param($k, $v); } return $this; } if (BNULL===$value) { return isset($this->_params[$key]) ? $this->_params[$key] : null; } $this->_params[$key] = $value; return $this; } public function set($name, $value=null) { if (is_array($name)) { foreach ($name as $k=>$v) { $this->_params['args'][$k] = $v; } return $this; } $this->_params['args'][$name] = $value; return $this; } public function get($name) { return isset($this->_params['args'][$name]) ? $this->_params['args'][$name] : null; } public function __get($name) { return $this->get($name); } public function __set($name, $value) { return $this->set($name, $value); } public function __isset($name) { return isset($this->_params['args'][$name]); } public function __unset($name) { unset($this->_pararms['args'][$name]); } public function view($viewname) { if ($viewname===$this->param('name')) { throw new BException(BApp::t('Circular reference detected: %s', $viewname)); } return BLayout::i()->view($viewname); } protected function _render() { $module = BModuleRegistry::i()->currentModule(); $template = ($module ? $module->view_root_dir.'/' : ''); $template .= ($tpl = $this->param('template')) ? $tpl : ($this->param('name').'.php'); ob_start(); include $template; return ob_get_clean(); } public function render(array $args=array()) { if ($this->param('raw_text')!==null) { return $this->param('raw_text'); } foreach ($args as $k=>$v) { $this->_params['args'][$k] = $v; } if (($modName = $this->param('module_name'))) { BModuleRegistry::i()->currentModule($modName); } $result = $this->_render(); if ($modName) { BModuleRegistry::i()->currentModule(null); } return $result; } public function clear() { unset($this->_params); } public function __destruct() { $this->clear(); } public function __toString() { try { $result = $this->render(); } catch (PDOException $e) { $result = '<hr>'.get_class($e).': '.$e->getMessage().'<hr>'.ORM::get_last_query().'<hr>'; } catch (Exception $e) { $result = '<hr>'.get_class($e).': '.$e->getMessage().'<hr>'; } return $result; } public function q($str) { if (is_null($str)) { return ''; } if (!is_string($str)) { var_dump($str); return ' ** ERROR ** '; } return htmlspecialchars($str); } public function email($p=array()) { static $availHeaders = array('to','from','cc','bcc','reply-to','return-path'); if (is_string($p)) { $p = array('to'=>$p); } $body = $this->render($p); $headers = array(); $params = array(); if (preg_match_all('#<!--\{\s*(.*?):\s*(.*?)\s*\}-->#i', $body, $matches, PREG_SET_ORDER)) { foreach ($matches as $m) { $lh = strtolower($m[1]); if ($lh=='subject') { $subject = $m[2]; } elseif ($lh=='to') { $to = $m[2]; } elseif (in_array($lh, $availHeaders)) { $headers[$lh] = $m[1].': '.$m[2]; } $body = preg_replace('/'.preg_quote($m[0]).'/', '', $body); } } foreach ($p as $k=>$v) { $lh = strtolower($k); if ($lh=='subject') { $subject = $v; } elseif ($lh=='to') { $to = $v; } elseif (in_array($lh, $availHeaders)) { $headers[$lh] = $k.': '.$v; } elseif ($k=='-f') $params[$k] = $k.' '.$v; } return mail($to, $subject, trim($body), join("\r\n", $headers), join(' ', $params)); } } class BViewHead extends BView { static protected $_defaultClass = __CLASS__; protected $_meta = array(); protected $_elements = array(); protected $_defaultTag = array( 'js' => '<script type="text/javascript" src="%s" %a></script>', 'css' => '<link rel="stylesheet" type="text/css" href="%s" %a/>', ); protected $_currentIfContext = null; public function meta($name=BNULL, $content=BNULL, $httpEquiv=false) { if (BNULL===$name) { return join("\n", $this->_meta); } if (BNULL===$content) { return !empty($this->_meta[$name]) ? $this->_meta[$name] : null; } if ($httpEquiv) { $this->_meta[$name] = '<meta http-equiv="'.$name.'" content="'.htmlspecialchars($content).'" />'; } else { $this->_meta[$name] = '<meta name="'.$name.'" content="'.htmlspecialchars($content).'" />'; } return $this; } protected function _externalResource($type, $name=BNULL, $args=BNULL) { if (BNULL===$name) { if (empty($this->_elements[$type])) { return ''; } $result = ''; foreach ($this->_elements[$type] as $name=>$args) { $result .= $this->_externalResource($type, $name, BNULL)."\n"; } return $result; } if (BNULL===$args) { if (empty($this->_elements[$type][$name])) { return null; } $args = $this->_elements[$type][$name]; $tag = !empty($args['tag']) ? $args['tag'] : $this->_defaultTag[$type]; $file = !empty($args['file']) ? $args['file'] : $name; $params = !empty($args['params']) ? $args['params'] : ''; if (strpos($file, 'http:')===false && strpos($file, 'https:')===false && $file[0]!=='/') { $module = !empty($args['module_name']) ? BModuleRegistry::i()->module($args['module_name']) : null; $baseUrl = $module ? $module->base_url : BApp::baseUrl(); $file = $baseUrl.'/'.$file; } $tag = str_replace('%s', htmlspecialchars($file), $tag); $tag = str_replace('%a', $params, $tag); if (!empty($args['if'])) { $tag = '<!--[if '.$args['if'].']>'.$tag.'<![endif]-->'; } return $tag; } elseif (!is_array($args)) { throw new BException(BApp::t('Invalid %s args: %s', array(strtoupper($type), print_r($args, 1)))); } if (($moduleName = BModuleRegistry::currentModuleName())) { $args['module_name'] = $moduleName; } if ($this->_currentIfContext) { $args['if'] = $this->_currentIfContext; } $this->_elements[$type][$name] = $args; return $this; } public function js($name=BNULL, $args=BNULL) { return $this->_externalResource('js', $name, $args); } public function css($name=BNULL, $args=BNULL) { return $this->_externalResource('css', $name, $args); } public function ifContext($context=null) { $this->_currentIfContext = $context; return $this; } public function render(array $args=array()) { if (!$this->param('template')) { return $this->meta()."\n".$this->css()."\n".$this->js(); } return parent::render($args); } } class BViewList extends BView { static protected $_defaultClass = __CLASS__; protected $_children = array(); protected $_lastPosition = 0; public function append($viewname, array $params=array()) { if (is_string($viewname)) { $viewname = explode(',', $viewname); } if (isset($params['position'])) { $this->_lastPosition = $params['position']; } foreach ($viewname as $v) { $params['name'] = $v; $params['position'] = $this->_lastPosition++; $this->_children[] = $params; } return $this; } public function appendText($text) { $layout = BLayout::i(); for ($viewname = md5(mt_rand()); $layout->view($viewname); ); $layout->view($viewname, array('raw_text'=>(string)$text)); $this->append($viewname); return $this; } public function find($content) { foreach ($this->_children as $i=>$child) { $view = $this->view($child['name']); if (strpos($view->render(), $content)!==false) { return $view; } } return null; } public function remove($viewname) { if (true===$viewname) { $this->_children = array(); return $this; } foreach ($this->_children as $i=>$child) { if ($child['name']==$viewname) { unset($this->_children[$i]); break; } } return $this; } public function render(array $args=array()) { $output = array(); uasort($this->_children, array($this, 'sortChildren')); $layout = BLayout::i(); foreach ($this->_children as $child) { $childView = $layout->view($child['name']); if (!$childView) { throw new BException(BApp::t('Invalid view name: %s', $child['name'])); } $output[] = $childView->render($args); } return join('', $output); } public function sortChildren($a, $b) { return $a['position']<$b['position'] ? -1 : ($a['position']>$b['position'] ? 1 : 0); } }  class BUser extends BModel { protected static $_sessionUser; public function sessionUserId() { $userId = BSession::i()->data('user_id'); return $userId ? $userId : false; } public function sessionUser($reset=false) { if (!static::isLoggedIn()) { return false; } $session = BSession::i(); if ($reset || !static::$_sessionUser) { static::$_sessionUser = $this->load($this->sessionUserId()); } return static::$_sessionUser; } public function isLoggedIn() { return $this->sessionUserId() ? true : false; } public function password($password) { $this->password_hash = BUtil::fullSaltedHash($password); return $this; } public function authenticate($username, $password) { if (empty(static::$_table)) { return $username=='admin' && $password=='admin'; } $user = $this->load($username, 'email'); if (!BUtil::validateSaltedHash($password, $user->password_hash)) { return false; } return $user; } public function authorize($role, $args=null) { if (is_null($args)) { return true; } return $this; } public function login($username, $password) { if (empty(static::$_table)) { return $this->altAuthenticate($username, $password); } $user = $this->authenticate($username, $password); if (!$user) { return false; } BSession::i()->data('user_id', $user->id); if ($user->locale) { setlocale(LC_ALL, $user->locale); } if ($user->timezone) { date_default_timezone_set($user->timezone); } BEventRegistry::i()->dispatch('BUser::login.after', array('user'=>$user)); return true; } public function logout() { BSession::i()->data('user_id', false); static::$_sessionUser = null; BEventRegistry::i()->dispatch('BUser::login.after'); return $this; } } class BDebug extends BClass { const MODE_DEBUG = 'debug', MODE_DEVELOPMENT = 'development', MODE_STAGING = 'staging', MODE_PRODUCTION = 'production'; protected $_startTime; protected $_events = array(); protected $_mode = 'development'; public function __construct() { $this->_startTime = microtime(true); BEventRegistry::i()->observe('BResponse::output.after', array($this, 'afterOutput')); } public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function mode($mode=null) { if (is_null($mode)) { return $this->_mode; } $this->_mode = $mode; return $this; } public function is($modes) { if (is_string($modes)) $modes = explode(',', $modes); return in_array($this->_mode, $modes); } public function log($event) { if (!$this->is('debug,development')) { return $this; } $event['ts'] = microtime(); if (($moduleName = BModuleRegistry::currentModuleName())) { $event['module'] = $moduleName; } $this->_events[] = $event; return $this; } public function dumpLog() { echo '<hr><pre style="border:solid 1px #f00; background:#fff; text-align:left; width:100%">'; print_r(BORM::get_query_log()); print_r($this->_events); echo "</pre>"; } public function delta() { return microtime(true)-$this->_startTime; } public static function dump($var) { if (is_array($var) && current($var) instanceof Model) { foreach ($var as $k=>$v) { echo '<hr>'.$k.':'; static::dump($v); } } elseif ($var instanceof Model) { echo '<pre>'; print_r($var->as_array()); echo '</pre>'; } else { echo '<pre>'; print_r($var); echo '</pre>'; } } public function afterOutput() { if ($this->_mode=='debug') { $this->dumpLog(); } } } class BCache extends BClass { public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function init() { } } class BLocale extends BClass { protected $_defaultTz = 'America/Los_Angeles'; protected $_defaultLocale = 'en_US'; protected $_tzCache = array(); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { date_default_timezone_set($this->_defaultTz); setlocale(LC_ALL, $this->_defaultLocale); $this->_tzCache['GMT'] = new DateTimeZone('GMT'); } public function t($string, $args=array()) { return BUtil::sprintfn($string, $args); } public function serverTz() { return date('e'); } public function tzOffset($tz=null) { if (is_null($tz)) { return date('O') * 36; } if (empty($this->_tzCache[$tz])) { $this->_tzCache[$tz] = new DateTimeZone($tz); } return $this->_tzCache[$tz]->getOffset($this->_tzCache['GMT']); } public function datetimeLocalToDb($value) { if (is_array($value)) { return array_map(array($this, __METHOD__), $value); } if (!$value) return $value; return gmstrftime('%F %T', strtotime($value)); } public function parseRequestDates($request, $fields=null) { if (is_string($fields)) $fields = explode(',', $fields); $isObject = is_object($request); $result = $isObject ? clone $request : $request; foreach ($request as $k=>$v) { if (!is_null($fields) && !in_array($k, $fields)) continue; $r = $this->datetimeLocalToDb($v); if ($isObject) $result->$k = $r; else $result[$k] = $r; } return $result; } public function datetimeDbToLocal($value, $full=false) { return strftime($full ? '%c' : '%x', strtotime($value)); } } class BUnit extends BClass { protected $_currentTest; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function test($methods) { } } 